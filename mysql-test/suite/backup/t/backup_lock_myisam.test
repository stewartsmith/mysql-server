#
# This test was created to ensure appropriate locks are obtained on the myisam
# tables during a myisam native driver restore. See BUG#36749.
#
# The test uses two connections and debug synchronization to ensure the restore
# in the middle of processing when a trigger attempts to insert data.
#

--source include/not_embedded.inc
--source include/have_innodb.inc
--source include/have_debug_sync.inc

SET DEBUG_SYNC= 'RESET';

connect(con1, localhost, root,,);
connect(con2, localhost, root,,);
connect(breakpoints, localhost, root,,);

--echo From con1:
--connection con1

--disable_warnings
DROP DATABASE IF EXISTS db1;
DROP DATABASE IF EXISTS db2;
DROP DATABASE IF EXISTS db3;
--enable_warnings

--error 0, 1
--remove_file $MYSQLTEST_VARDIR/master-data/db1.bak

--error 0, 1
--remove_file $MYSQLTEST_VARDIR/master-data/db3.bak

--echo Create database 1 and a table then populate it
CREATE DATABASE db1;
CREATE TABLE db1.t1 (a INT) ENGINE=MYISAM;

INSERT INTO db1.t1 VALUES (1),(2),(3),(4),(5),(6),(7),(8),(9),(0);
INSERT INTO db1.t1 SELECT * FROM db1.t1;
INSERT INTO db1.t1 SELECT * FROM db1.t1;
INSERT INTO db1.t1 SELECT * FROM db1.t1;
INSERT INTO db1.t1 SELECT * FROM db1.t1;
INSERT INTO db1.t1 SELECT * FROM db1.t1;
INSERT INTO db1.t1 SELECT * FROM db1.t1;
INSERT INTO db1.t1 SELECT * FROM db1.t1;
INSERT INTO db1.t1 SELECT * FROM db1.t1;
INSERT INTO db1.t1 SELECT * FROM db1.t1;

INSERT INTO db1.t1 SELECT * FROM db1.t1;
INSERT INTO db1.t1 SELECT * FROM db1.t1;
INSERT INTO db1.t1 SELECT * FROM db1.t1;
INSERT INTO db1.t1 SELECT * FROM db1.t1;
INSERT INTO db1.t1 SELECT * FROM db1.t1;
INSERT INTO db1.t1 SELECT * FROM db1.t1;

CREATE TABLE db1.t2 (a int) ENGINE=MEMORY;

INSERT INTO db1.t2 VALUES (1),(2),(3),(4),(5);

CREATE TABLE db1.t3 (a int) ENGINE=INNODB;

INSERT INTO db1.t3 VALUES (11),(12),(13);

--echo Show initial count of table
SELECT COUNT(*) FROM db1.t1;

SELECT COUNT(*) FROM db1.t2;

SELECT COUNT(*) FROM db1.t3;

--echo From con2:
--connection con2

--echo Create database 2 and a table then populate it and add a trigger
--echo that updates the table in database 1

CREATE DATABASE db2;
CREATE TABLE db2.t2 (A INT);

DELIMITER |;

CREATE TRIGGER db2.trg AFTER INSERT ON db2.t2 FOR EACH ROW
BEGIN
  INSERT INTO db1.t1 VALUES ('99');
END|

delimiter ;|

--echo From con1:
--connection con1

--echo Now do the backup 
--replace_column 1 #
BACKUP DATABASE db1 TO 'db1.bak';

DROP DATABASE db1;

--echo now start the restore and while the restore is running, fire the trigger
--echo activate synchronization points for restore.
SET DEBUG_SYNC= 'restore_in_progress SIGNAL wait_for_restore WAIT_FOR finish';
--send RESTORE FROM 'db1.bak' OVERWRITE;

--echo From breakpoints:
--connection breakpoints
--echo Wait for restore to reach its synchronization point.
SET DEBUG_SYNC= 'now WAIT_FOR wait_for_restore';

--echo breakpoints: Show process list.
--replace_column 1 #
query_vertical SELECT id, command, state, info FROM INFORMATION_SCHEMA.PROCESSLIST
WHERE info LIKE "RESTORE%";

--echo From con2:
--connection con2
--echo Now do the insert while restore is running.
send INSERT INTO db2.t2 VALUES (0);

--echo From breakpoints:
--connection breakpoints
--echo breakpoints: Sending finish signal to wake restore.
SET DEBUG_SYNC= 'now SIGNAL finish';

--echo Reattach to connection 2 and finish.
--connection con2
--reap

--echo Reattach to connection 1 and finish.
--connection con1
--replace_column 1 #
--reap

--echo Show the count for t1. It should be 1 more than before restore.
SELECT COUNT(*) FROM db1.t1;

SELECT * FROM db1.t2;

SELECT * FROM db1.t3;

SET DEBUG_SYNC= 'RESET';

#
# BUG#36778 - Data loss during select at time of restore.
#

DELETE FROM db2.t2;

--echo now start the restore and while the restore is running, fire the trigger
--echo activate synchronization points for restore.
SET DEBUG_SYNC= 'restore_in_progress SIGNAL wait_for_restore WAIT_FOR finish';
--send RESTORE FROM 'db1.bak' OVERWRITE;

--echo From breakpoints:
--connection breakpoints
--echo Wait for restore to reach its synchronization point.
SET DEBUG_SYNC= 'now WAIT_FOR wait_for_restore';

--echo breakpoints: Show process list.
--replace_column 1 #
query_vertical SELECT id, command, state, info FROM INFORMATION_SCHEMA.PROCESSLIST
WHERE info LIKE "RESTORE%";

--echo From con2:
--connection con2
--echo Now do the select while restore is running.
send SELECT * FROM db1.t1 limit 10;

--echo From breakpoints:
--connection breakpoints
--echo breakpoints: Sending finish signal to wake restore.
SET DEBUG_SYNC= 'now SIGNAL finish';

--echo Reattach to connection 2 and finish.
--connection con2
--reap

--echo Reattach to connection 1 and finish.
--connection con1
--replace_column 1 #
--reap

--echo Show the count for t1. It should be the same as before restore.
SELECT COUNT(*) FROM db1.t1;

SELECT * FROM db1.t2;

SELECT * FROM db1.t3;

SET DEBUG_SYNC= 'RESET';

#
# BUG#36782 - Data loss with restore of view.
#

--echo Create a database with a table and a view using the MyISAM engine.
CREATE DATABASE db3;
CREATE TABLE db3.t1(name CHAR(10)) ENGINE=MYISAM;
INSERT INTO db3.t1 VALUES('A'),('B'),('C'),('D');
CREATE VIEW db3.v1 AS SELECT * FROM db3.t1;

--echo Show the data before backup
SELECT * FROM db3.t1;
SELECT * FROM db3.v1;

--echo Backup the database.
--replace_column 1 #
BACKUP DATABASE db3 TO 'db3.bak';

--echo Now drop then restore the database.
DROP DATABASE db3;
--replace_column 1 #
RESTORE FROM 'db3.bak';

--echo Show the table and view.
SHOW FULL TABLES FROM db3;

--echo Show the data after restore.
SELECT * FROM db3.v1;
SELECT * FROM db3.t1;

--echo cleanup
DROP DATABASE db1;
DROP DATABASE db2;
DROP DATABASE db3;

--error 0, 1
--remove_file $MYSQLTEST_VARDIR/master-data/db1.bak

--error 0, 1
--remove_file $MYSQLTEST_VARDIR/master-data/db3.bak
