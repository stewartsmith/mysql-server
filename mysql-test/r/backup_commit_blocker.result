SET DEBUG_SYNC= 'RESET';
DROP DATABASE IF EXISTS bup_commit_blocker;
CREATE DATABASE bup_commit_blocker;

Starting Test 1

con1: Creating tables
CREATE TABLE bup_commit_blocker.t1 (col_a CHAR(40)) ENGINE=INNODB;
CREATE TABLE bup_commit_blocker.t2 (col_a CHAR(40)) ENGINE=INNODB;
CREATE TABLE bup_commit_blocker.t3 (col_a CHAR(40)) ENGINE=INNODB;
con1: Loading data
INSERT INTO bup_commit_blocker.t1 VALUES ("01 Some data to test");
INSERT INTO bup_commit_blocker.t1 VALUES ("02 Some data to test");
INSERT INTO bup_commit_blocker.t1 VALUES ("03 Some data to test");
INSERT INTO bup_commit_blocker.t1 VALUES ("04 Some data to test");
INSERT INTO bup_commit_blocker.t1 VALUES ("05 Some data to test");
INSERT INTO bup_commit_blocker.t2 VALUES ("01 Some data to test");
INSERT INTO bup_commit_blocker.t2 VALUES ("02 Some data to test");
INSERT INTO bup_commit_blocker.t2 VALUES ("03 Some data to test");
INSERT INTO bup_commit_blocker.t2 VALUES ("04 Some data to test");
INSERT INTO bup_commit_blocker.t2 VALUES ("05 Some data to test");
INSERT INTO bup_commit_blocker.t3 VALUES ("01 Some data to test");
INSERT INTO bup_commit_blocker.t3 VALUES ("02 Some data to test");
INSERT INTO bup_commit_blocker.t3 VALUES ("03 Some data to test");
INSERT INTO bup_commit_blocker.t3 VALUES ("04 Some data to test");
INSERT INTO bup_commit_blocker.t3 VALUES ("05 Some data to test");
con1: Show that the new data doesn't exist before backup.
SELECT * FROM bup_commit_blocker.t1;
col_a
01 Some data to test
02 Some data to test
03 Some data to test
04 Some data to test
05 Some data to test
SELECT * FROM bup_commit_blocker.t2;
col_a
01 Some data to test
02 Some data to test
03 Some data to test
04 Some data to test
05 Some data to test
SELECT * FROM bup_commit_blocker.t3;
col_a
01 Some data to test
02 Some data to test
03 Some data to test
04 Some data to test
05 Some data to test
con2: Get a transaction going and stop in the middle
Assumption (a): TRX in progress is not included in backup
BEGIN;
UPDATE bup_commit_blocker.t1 SET col_a = "con2: CHANGED" WHERE col_a LIKE '01%';
con3: Start a transaction and send commit after lock is taken
Assumption (b): TRX in commit is included in backup
BEGIN;
INSERT INTO bup_commit_blocker.t2 VALUES ("con3: 04 Some data to test");
INSERT INTO bup_commit_blocker.t2 VALUES ("con3: 05 Some data to test");
con1: Activate synchronization points for BACKUP.
SET DEBUG_SYNC= 'before_commit_block SIGNAL bup_commit_block
                 WAIT_FOR bup_go_read_lock';
SET DEBUG_SYNC= 'wait_lock_global_read_lock SIGNAL bup_read_lock';
SET DEBUG_SYNC= 'before_backup_data_lock WAIT_FOR commit_done';
SET DEBUG_SYNC= 'before_backup_unblock_commit SIGNAL bup_read_locked
                 WAIT_FOR finish';
con1: Backing up database -- will block with lock
BACKUP DATABASE bup_commit_blocker TO "bup_commit_blocker.bak";
con5: Wait for BACKUP to reach its synchronization point.
SET DEBUG_SYNC= 'now WAIT_FOR bup_commit_block';
SELECT state, info FROM
INFORMATION_SCHEMA.PROCESSLIST
WHERE info LIKE "BACKUP DATABASE%";
state	info
debug sync point: before_commit_block	BACKUP DATABASE bup_commit_blocker TO "bup_commit_blocker.bak"
con3: Activate synchronization points for COMMIT.
SET DEBUG_SYNC= 'within_ha_commit_trans SIGNAL commit_read_locked
                 WAIT_FOR commit_go_done';
SET DEBUG_SYNC= 'after_commit SIGNAL commit_done WAIT_FOR finish';
con3: Starting commit -- will block on sync point
COMMIT;
con5: Wait for COMMIT to reach its synchronization point.
SET DEBUG_SYNC= 'now WAIT_FOR commit_read_locked';
SELECT state, info FROM
INFORMATION_SCHEMA.PROCESSLIST
WHERE info LIKE "COMMIT%";
state	info
debug sync point: within_ha_commit_trans	COMMIT
con5: Let BACKUP run until the next sync point.
SET DEBUG_SYNC= 'now SIGNAL bup_go_read_lock WAIT_FOR bup_read_lock';
SELECT state, info FROM
INFORMATION_SCHEMA.PROCESSLIST
WHERE info LIKE "BACKUP DATABASE%";
state	info
Waiting to get readlock	BACKUP DATABASE bup_commit_blocker TO "bup_commit_blocker.bak"
con5: Let COMMIT continue until end of statement.
con5: The completed COMMIT implicitly wakes BACKUP.
con5: So wait for BACKUP to reach the next synchronization point.
SET DEBUG_SYNC= 'now SIGNAL commit_go_done WAIT_FOR bup_read_locked';
SELECT state, info FROM
INFORMATION_SCHEMA.PROCESSLIST
WHERE info LIKE "COMMIT%";
state	info
debug sync point: after_commit	COMMIT
SELECT state, info FROM
INFORMATION_SCHEMA.PROCESSLIST
WHERE info LIKE "BACKUP DATABASE%";
state	info
debug sync point: before_backup_unblock_commit	BACKUP DATABASE bup_commit_blocker TO "bup_commit_blocker.bak"
con4: Activate synchronization point for BEGIN.
SET DEBUG_SYNC= 'before_begin_trans SIGNAL begin_starting
                 WAIT_FOR finish';
con4: Starting begin -- will block on sync point
Assumption (c): TRX not started is not included in backup
BEGIN;
con5: Wait for BEGIN to reach its synchronization point.
SET DEBUG_SYNC= 'now WAIT_FOR begin_starting';
SELECT state, info FROM
INFORMATION_SCHEMA.PROCESSLIST
WHERE info LIKE "BEGIN%";
state	info
debug sync point: before_begin_trans	BEGIN
con5: Sending finish signal to wake them all.
SET DEBUG_SYNC= 'now SIGNAL finish';
con2: Completing transaction
DELETE FROM bup_commit_blocker.t1 WHERE col_a LIKE '02%';
COMMIT;
con3: Fetch COMMIT result
con4: Fetch BEGIN result and completing transaction
UPDATE bup_commit_blocker.t3 SET col_a = "con4: 05 CHANGED" WHERE col_a LIKE '05%';
UPDATE bup_commit_blocker.t3 SET col_a = "con4: 06 CHANGED" WHERE col_a LIKE '06%';
COMMIT;
con1: Fetch BACKUP result
backup_id
#
con1: Showing data after updates and backup
SELECT * FROM bup_commit_blocker.t1;
col_a
con2: CHANGED
03 Some data to test
04 Some data to test
05 Some data to test
SELECT * FROM bup_commit_blocker.t2;
col_a
01 Some data to test
02 Some data to test
03 Some data to test
04 Some data to test
05 Some data to test
con3: 04 Some data to test
con3: 05 Some data to test
SELECT * FROM bup_commit_blocker.t3;
col_a
01 Some data to test
02 Some data to test
03 Some data to test
04 Some data to test
con4: 05 CHANGED
con1: Dropping the database
DROP TABLE bup_commit_blocker.t1;
DROP TABLE bup_commit_blocker.t2;
DROP TABLE bup_commit_blocker.t3;
con1: Restoring the database
RESTORE FROM "bup_commit_blocker.bak";
backup_id
#
con1: Showing the data (no new data should be here).
SELECT * FROM bup_commit_blocker.t1;
col_a
01 Some data to test
02 Some data to test
03 Some data to test
04 Some data to test
05 Some data to test
SELECT * FROM bup_commit_blocker.t2;
col_a
01 Some data to test
02 Some data to test
03 Some data to test
04 Some data to test
05 Some data to test
con3: 04 Some data to test
con3: 05 Some data to test
SELECT * FROM bup_commit_blocker.t3;
col_a
01 Some data to test
02 Some data to test
03 Some data to test
04 Some data to test
05 Some data to test

Verifying test 1 results:

T1 should not have the changes after backup - count(*) = 0
SELECT count(*) FROM bup_commit_blocker.t1 WHERE col_a like 'con2%';
count(*)
0
T2 should have the changes after backup - count(*) = 2
SELECT count(*) FROM bup_commit_blocker.t2 WHERE col_a like 'con3%';
count(*)
2
T3 should not have the changes after backup - count(*) = 0
SELECT count(*) FROM bup_commit_blocker.t3 WHERE col_a like 'con4%';
count(*)
0
con1: Cleanup
DROP DATABASE bup_commit_blocker;
SET DEBUG_SYNC= 'RESET';

Starting Test 2

CREATE DATABASE bup_commit_blocker;
con1: Creating tables
CREATE TABLE bup_commit_blocker.t5 (col_a int) ENGINE=MEMORY;
con1: Loading data
INSERT INTO bup_commit_blocker.t5 VALUES (10), (20), (30), (40), (50);
con1: Show that the new data doesn't exist before backup.
SELECT * FROM bup_commit_blocker.t5;
col_a
10
20
30
40
50
con1: Activate synchronization point for BACKUP.
SET DEBUG_SYNC= 'before_backup_data_unlock SIGNAL bup_data_unlock
                 WAIT_FOR finish';
con1: Backing up database -- will block with lock
BACKUP DATABASE bup_commit_blocker TO "bup_commit_blocker.bak";
con5: Wait for BACKUP to reach its synchronization point.
SET DEBUG_SYNC= 'now WAIT_FOR bup_data_unlock';
SELECT state, info FROM
INFORMATION_SCHEMA.PROCESSLIST
WHERE info LIKE "BACKUP DATABASE%";
state	info
debug sync point: before_backup_data_unlock	BACKUP DATABASE bup_commit_blocker TO "bup_commit_blocker.bak"
con7: Show that the statement in progress has executed before backup.
SELECT * FROM bup_commit_blocker.t5;
col_a
10
20
30
40
50
con7: Activate synchronization point for UPDATE.
SET DEBUG_SYNC= 'wait_if_global_read_lock SIGNAL upd_read_lock';
con7: Starting non-trx about to start
Assumption (e): non-TRX not started is not included in backup
UPDATE bup_commit_blocker.t5 SET col_a = 333 WHERE col_a = 30;
con5: Wait for UPDATE to reach its synchronization point.
SET DEBUG_SYNC= 'now WAIT_FOR upd_read_lock';
SELECT state, info FROM
INFORMATION_SCHEMA.PROCESSLIST
WHERE info LIKE "UPDATE%";
state	info
Waiting for release of readlock	UPDATE bup_commit_blocker.t5 SET col_a = 333 WHERE col_a = 30
con5: Sending finish signal to wake them all.
SET DEBUG_SYNC= 'now SIGNAL finish';
con7: Fetch UPDATE result
con1: Fetch BACKUP result
backup_id
#
con1: Showing data after updates and backup
SELECT * FROM bup_commit_blocker.t5;
col_a
10
20
333
40
50
con1: Dropping the database
DROP TABLE bup_commit_blocker.t5;
con1: Restoring the database
RESTORE FROM "bup_commit_blocker.bak";
backup_id
#
con1: Showing the data (no new data should be here).
SELECT * FROM bup_commit_blocker.t5;
col_a
10
20
30
40
50

Verifying test 2 results:

T5 should not have the changes after backup - count(*) = 0
SELECT count(*) FROM bup_commit_blocker.t5 WHERE col_a = 333;
count(*)
0
con1: Cleanup
DROP DATABASE bup_commit_blocker;
SET DEBUG_SYNC= 'RESET';

Starting Test 3

CREATE DATABASE bup_commit_blocker;
con1: Creating tables
CREATE TABLE bup_commit_blocker.t1 (col_a CHAR(40)) ENGINE=INNODB;
CREATE TABLE bup_commit_blocker.t2 (col_a CHAR(40)) ENGINE=INNODB;
CREATE TABLE bup_commit_blocker.t3 (col_a CHAR(40)) ENGINE=INNODB;
CREATE TABLE bup_commit_blocker.t5 (col_a int) ENGINE=MEMORY;
con1: Loading data
INSERT INTO bup_commit_blocker.t1 VALUES ("01 Some data to test");
INSERT INTO bup_commit_blocker.t1 VALUES ("02 Some data to test");
INSERT INTO bup_commit_blocker.t1 VALUES ("03 Some data to test");
INSERT INTO bup_commit_blocker.t1 VALUES ("04 Some data to test");
INSERT INTO bup_commit_blocker.t1 VALUES ("05 Some data to test");
INSERT INTO bup_commit_blocker.t2 VALUES ("01 Some data to test");
INSERT INTO bup_commit_blocker.t2 VALUES ("02 Some data to test");
INSERT INTO bup_commit_blocker.t2 VALUES ("03 Some data to test");
INSERT INTO bup_commit_blocker.t2 VALUES ("04 Some data to test");
INSERT INTO bup_commit_blocker.t2 VALUES ("05 Some data to test");
INSERT INTO bup_commit_blocker.t3 VALUES ("01 Some data to test");
INSERT INTO bup_commit_blocker.t3 VALUES ("02 Some data to test");
INSERT INTO bup_commit_blocker.t3 VALUES ("03 Some data to test");
INSERT INTO bup_commit_blocker.t3 VALUES ("04 Some data to test");
INSERT INTO bup_commit_blocker.t3 VALUES ("05 Some data to test");
INSERT INTO bup_commit_blocker.t5 VALUES (10), (20), (30), (40), (50);
con1: Show that the new data doesn't exist before backup.
SELECT * FROM bup_commit_blocker.t1;
col_a
01 Some data to test
02 Some data to test
03 Some data to test
04 Some data to test
05 Some data to test
SELECT * FROM bup_commit_blocker.t2;
col_a
01 Some data to test
02 Some data to test
03 Some data to test
04 Some data to test
05 Some data to test
SELECT * FROM bup_commit_blocker.t3;
col_a
01 Some data to test
02 Some data to test
03 Some data to test
04 Some data to test
05 Some data to test
SELECT * FROM bup_commit_blocker.t5;
col_a
10
20
30
40
50
con2: Get a transaction going and stop in the middle
Assumption (a): TRX in progress is not included in backup
BEGIN;
UPDATE bup_commit_blocker.t1 SET col_a = "con2: CHANGED" WHERE col_a LIKE '01%';
con3: Start a transaction and send commit after lock is taken
Assumption (b): TRX in commit is included in backup
BEGIN;
INSERT INTO bup_commit_blocker.t2 VALUES ("con3: 04 Some data to test");
INSERT INTO bup_commit_blocker.t2 VALUES ("con3: 05 Some data to test");
con1: Activate synchronization points for BACKUP.
SET DEBUG_SYNC= 'before_commit_block SIGNAL bup_commit_block
                 WAIT_FOR bup_go_read_lock';
SET DEBUG_SYNC= 'wait_lock_global_read_lock SIGNAL bup_read_lock';
SET DEBUG_SYNC= 'before_backup_data_lock WAIT_FOR commit_done';
SET DEBUG_SYNC= 'before_backup_unblock_commit SIGNAL bup_read_locked
                 WAIT_FOR finish';
con1: Backing up database -- will block with lock
BACKUP DATABASE bup_commit_blocker TO "bup_commit_blocker.bak";
con5: Wait for BACKUP to reach its synchronization point.
SET DEBUG_SYNC= 'now WAIT_FOR bup_commit_block';
SELECT state, info FROM
INFORMATION_SCHEMA.PROCESSLIST
WHERE info LIKE "BACKUP DATABASE%";
state	info
debug sync point: before_commit_block	BACKUP DATABASE bup_commit_blocker TO "bup_commit_blocker.bak"
con3: Activate synchronization points for COMMIT.
SET DEBUG_SYNC= 'within_ha_commit_trans SIGNAL commit_read_locked
                 WAIT_FOR commit_go_done';
SET DEBUG_SYNC= 'after_commit SIGNAL commit_done WAIT_FOR finish';
con3: Starting commit -- will block on sync point
COMMIT;
con5: Wait for COMMIT to reach its synchronization point.
SET DEBUG_SYNC= 'now WAIT_FOR commit_read_locked';
SELECT state, info FROM
INFORMATION_SCHEMA.PROCESSLIST
WHERE info LIKE "COMMIT%";
state	info
debug sync point: within_ha_commit_trans	COMMIT
con5: Let BACKUP run until the next sync point.
SET DEBUG_SYNC= 'now SIGNAL bup_go_read_lock WAIT_FOR bup_read_lock';
SELECT state, info FROM
INFORMATION_SCHEMA.PROCESSLIST
WHERE info LIKE "BACKUP DATABASE%";
state	info
Waiting to get readlock	BACKUP DATABASE bup_commit_blocker TO "bup_commit_blocker.bak"
con5: Let COMMIT continue until the sync point at its end.
con5: The completed COMMIT implicitly wakes BACKUP.
con5: So wait for BACKUP to reach the next synchronization point.
SET DEBUG_SYNC= 'now SIGNAL commit_go_done WAIT_FOR bup_read_locked';
SELECT state, info FROM
INFORMATION_SCHEMA.PROCESSLIST
WHERE info LIKE "COMMIT%";
state	info
debug sync point: after_commit	COMMIT
SELECT state, info FROM
INFORMATION_SCHEMA.PROCESSLIST
WHERE info LIKE "BACKUP DATABASE%";
state	info
debug sync point: before_backup_unblock_commit	BACKUP DATABASE bup_commit_blocker TO "bup_commit_blocker.bak"
con4: Activate synchronization point for BEGIN.
SET DEBUG_SYNC= 'before_begin_trans SIGNAL begin_starting
                 WAIT_FOR finish';
con4: Starting begin -- will block with lock
Assumption (c): TRX not started is not included in backup
BEGIN;
con5: Wait for BEGIN to reach its synchronization point.
SET DEBUG_SYNC= 'now WAIT_FOR begin_starting';
SELECT state, info FROM
INFORMATION_SCHEMA.PROCESSLIST
WHERE info LIKE "BEGIN%";
state	info
debug sync point: before_begin_trans	BEGIN
con7: Show that the statement in progress has executed before backup.
SELECT * FROM bup_commit_blocker.t5;
col_a
10
20
30
40
50
con7: Activate synchronization point for DELETE.
SET DEBUG_SYNC= 'wait_if_global_read_lock SIGNAL del_read_lock';
con7: Starting non-trx about to start -- will block with lock
Assumption (e): non-TRX not started is not included in backup
DELETE FROM bup_commit_blocker.t5 WHERE col_a = 50;
con5: Wait for DELETE to reach its synchronization point.
SET DEBUG_SYNC= 'now WAIT_FOR del_read_lock';
SELECT state, info FROM
INFORMATION_SCHEMA.PROCESSLIST
WHERE info LIKE "DELETE%";
state	info
Waiting for release of readlock	DELETE FROM bup_commit_blocker.t5 WHERE col_a = 50
con5: Sending finish signal to wake them all.
SET DEBUG_SYNC= 'now SIGNAL finish';
con2: Completing transaction
DELETE FROM bup_commit_blocker.t2 WHERE col_a LIKE '02%';
COMMIT;
con3: Fetch COMMIT result
con4: Fetch BEGIN result and completing transaction
UPDATE bup_commit_blocker.t3 SET col_a = "con4: 05 CHANGED" WHERE col_a LIKE '05%';
UPDATE bup_commit_blocker.t3 SET col_a = "con4: 06 CHANGED" WHERE col_a LIKE '06%';
COMMIT;
con7: Fetch DELETE result
con1: Fetch BACKUP result
backup_id
#
con1: Showing data after updates and backup
SELECT * FROM bup_commit_blocker.t1;
col_a
con2: CHANGED
02 Some data to test
03 Some data to test
04 Some data to test
05 Some data to test
SELECT * FROM bup_commit_blocker.t2;
col_a
01 Some data to test
03 Some data to test
04 Some data to test
05 Some data to test
con3: 04 Some data to test
con3: 05 Some data to test
SELECT * FROM bup_commit_blocker.t3;
col_a
01 Some data to test
02 Some data to test
03 Some data to test
04 Some data to test
con4: 05 CHANGED
SELECT * FROM bup_commit_blocker.t5;
col_a
10
20
30
40
con1: Dropping the database
DROP TABLE bup_commit_blocker.t1;
DROP TABLE bup_commit_blocker.t2;
DROP TABLE bup_commit_blocker.t3;
DROP TABLE bup_commit_blocker.t5;
con1: Restoring the database
RESTORE FROM "bup_commit_blocker.bak";
backup_id
#
con1: Showing the data (no new data should be here).
SELECT * FROM bup_commit_blocker.t1;
col_a
01 Some data to test
02 Some data to test
03 Some data to test
04 Some data to test
05 Some data to test
SELECT * FROM bup_commit_blocker.t2;
col_a
01 Some data to test
02 Some data to test
03 Some data to test
04 Some data to test
05 Some data to test
con3: 04 Some data to test
con3: 05 Some data to test
SELECT * FROM bup_commit_blocker.t3;
col_a
01 Some data to test
02 Some data to test
03 Some data to test
04 Some data to test
05 Some data to test
SELECT * FROM bup_commit_blocker.t5;
col_a
10
20
30
40
50

Verifying test 3 results:

T1 should not have the changes after backup - count(*) = 0
SELECT count(*) FROM bup_commit_blocker.t1 WHERE col_a like 'con2%';
count(*)
0
T2 should have the changes after backup - count(*) = 2
SELECT count(*) FROM bup_commit_blocker.t2 WHERE col_a like 'con3%';
count(*)
2
T3 should not have the changes after backup - count(*) = 0
SELECT count(*) FROM bup_commit_blocker.t3 WHERE col_a like 'con4%';
count(*)
0
T5 should not have the changes after backup - count(*) = 1
SELECT count(*) FROM bup_commit_blocker.t5 WHERE col_a >= 50;
count(*)
1
con1: Cleanup
DROP DATABASE bup_commit_blocker;
SET DEBUG_SYNC= 'RESET';
