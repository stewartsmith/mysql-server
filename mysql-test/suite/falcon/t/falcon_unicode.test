--source include/have_falcon.inc

#
# Unicode related tests for Falcon
#
# UnicodeData.txt is Copyright Â© 1991-2008 Unicode, Inc.
# All rights reserved. Distributed under the Terms of Use
# in http://www.unicode.org/copyright.html.
#
# Notes
#    Six Unicode code points are invalid in UTF-8,
#    but they get translated, leading to empty
#    UTF-8 values
#        [15:09] root@test>select id, hex(a), character_length(a) as len
#            -> from t0 where character_length(a) = 0;
#        +-------+--------+------+
#        | id    | hex(a) | len  |
#        +-------+--------+------+
#        | 13135 |        |    0 |
#        | 13136 |        |    0 |
#        | 13137 |        |    0 |
#        | 13138 |        |    0 |
#        | 13139 |        |    0 |
#        | 13140 |        |    0 |
#        +-------+--------+------+
#        6 rows in set (0.04 sec)
#
#    The code points in question are:
#      * D800;<Non Private Use High Surrogate, First>
#      * DB7F;<Non Private Use High Surrogate, Last>
#      * DB80;<Private Use High Surrogate, First>
#      * DBFF;<Private Use High Surrogate, Last>
#      * DC00;<Low Surrogate, First>
#      * DFFF;<Low Surrogate, Last>
#
#    The following two code points look suspicios but they
#    get translated to UTF-8:
#      * E000;<Private Use, First>
#      * F8FF;<Private Use, Last>
#
--echo *** Unicode tests ***

# ----------------------------------------------------- #
# --- Initialisation                                --- #
# ----------------------------------------------------- #
let $engine = 'Falcon';
let $other_engine = 'MyISAM';
eval SET @@storage_engine = $engine;

--disable_warnings
DROP TABLE IF EXISTS t0;
DROP TABLE IF EXISTS t1;
DROP TABLE IF EXISTS t2;
DROP TABLE IF EXISTS t3;
DROP TABLE IF EXISTS t4;
DROP TABLE IF EXISTS t5;
DROP TABLE IF EXISTS t_err;
--enable_warnings

# Reference table with MyISAM as storage engine.
eval
CREATE TABLE t0 (
  id int auto_increment not null primary key,
  a varchar(1) character set utf8,
  category  varchar(100),
  comment   varchar(80)
) Engine $other_engine;

# Falcon test table without any keys.
CREATE TABLE t1 (
  a char(1) character set utf8
);

# Falcon test table with PK.
CREATE TABLE t2 (
  a char(1) character set utf8 primary key
);

# Falcon test table with index.
CREATE TABLE t3 (
  a char(1) character set utf8,
  key (a)
);

# Falcon test table with unique index.
CREATE TABLE t4 (
  a char(1) character set utf8,
  unique key (a)
);

# Falcon test table with unique index not null.
CREATE TABLE t5 (
  a char(1) not null character set utf8,
  unique key (a)
);

# We collect any errors in this table.
eval
CREATE TABLE t_err (
  expected char(1) character set utf8,
  actual   char(1) character set utf8,
  category  varchar(100),
  comment   varchar(80)
) Engine $other_engine;

#
# Transform Unicode code points to UTF-8 and insert
# the characters into reference table. The transformation
# is done in place, so that the Unicode code point file
# can be updated in an easy fashion.
#
# Unicode to UTF-8 transformation algorithm is taken from
# http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&item_id=IWS-AppendixA
#
SET @one_byte =      CONV('007F', 16, 10);
SET @two_byte =      CONV('07FF', 16, 10);
SET @two_byte_low =  CONV('E000', 16, 10);
SET @two_byte_high = CONV('FFFF', 16, 10);
SET @three_byte =    CONV('D7FF', 16, 10);

#
# @todo How to substitute CONV(@var1, 16, 10) with a
# variable for easier reading?
#
LOAD DATA LOCAL INFILE 'include/UnicodeData.txt' INTO TABLE t0
  FIELDS TERMINATED BY ';'
  OPTIONALLY ENCLOSED BY ''
  LINES TERMINATED BY '\n'
  (@var1, @category, @dummy3, @dummy4, @dummy5, @dummy6, @dummy7,
   @dummy8, @dummy9, @dummy10, @comment, @dummy12, @dummy13, @dummy14, @dummy15)
SET a = (UNHEX((
  SELECT IF (CONV(@var1, 16, 10) + 0 <= @one_byte + 0,
             # One byte UTF-8, leave it as it is. The hex2hex conv() is done
             # to get rid of leading 00, which are distracting MySQL a bit.
             CONV(@var1, 16, 16),
             IF (CONV(@var1, 16, 10) + 0 <= @two_byte + 0,
                 # Two byte UTF-8.
                 CONCAT(CONV((CONV(@var1, 16, 10) DIV 64) + 192, 10, 16),
                        CONV((CONV(@var1, 16, 10) MOD 64) + 128, 10, 16)),
                 IF (CONV(@var1, 16, 10) + 0 <= @three_byte + 0
                     || (@two_byte_low + 0 <= CONV(@var1, 16, 10) + 0 && CONV(@var1, 16, 10) + 0 <= @two_byte_high + 0),
                     # Three byte UTF-8.
                     CONCAT(CONV((CONV(@var1, 16, 10) DIV 4096) + 224, 10, 16),
                            CONV(((CONV(@var1, 16, 10) MOD 4096) div 64) + 128, 10, 16),
                            CONV((CONV(@var1, 16, 10) MOD 64) + 128, 10, 16)),
                     # Four byte UTF-8.
                     CONCAT(CONV((CONV(@var1, 16, 10) DIV 262144) + 240, 10, 16),
                            CONV(((CONV(@var1, 16, 10) MOD 262144) DIV 4096) + 128, 10, 16),
                            CONV(((CONV(@var1, 16, 10) MOD 4096) DIV 64) + 128, 10, 16),
                            CONV((CONV(@var1, 16, 10) MOD 64) + 128, 10, 16))
                 )
             )
         )
  ))
), category = @category, comment = @comment;

# ----------------------------------------------------- #
# --- Test                                          --- #
# ----------------------------------------------------- #

# Case tests?

# Also test two UTF-8 characters with whitespace
# like TAB in between.

# ----------------------------------------------------- #
# --- Check                                         --- #
# ----------------------------------------------------- #
SELECT count(*) FROM t0;
SELECT count(*) FROM t1;
SELECT count(*) FROM t2;
SELECT count(*) FROM t3;
SELECT count(*) FROM t4;
SELECT count(*) FROM t5;
SELECT count(*) FROM t_err;

# ----------------------------------------------------- #
# --- Final cleanup                                 --- #
# ----------------------------------------------------- #
DROP TABLE t0;
DROP TABLE t1;
DROP TABLE t2;
DROP TABLE t3;
DROP TABLE t4;
DROP TABLE t5;
DROP TABLE t_err;
