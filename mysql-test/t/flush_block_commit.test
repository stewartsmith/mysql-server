# Let's see if FLUSH TABLES WITH READ LOCK blocks COMMIT of existing
# transactions.
# We verify that we did not introduce a deadlock.
# This is intended to mimick how mysqldump and innobackup work.

# And it requires InnoDB
-- source include/have_innodb.inc

connect (con1,localhost,root,,);
connect (con2,localhost,root,,);
connect (con3,localhost,root,,);
connection con1;

--disable_warnings
drop table if exists t1;
--enable_warnings
create table t1 (a int) engine=innodb;

# blocks COMMIT ?

begin;
insert into t1 values(1);
connection con2;
--send flush tables with read lock;
connection con1;
commit;
connection con2;
--reap
select * from t1;
unlock tables;

# No deadlock ?

connection con1;
begin;
select * from t1 for update;
connection con2;
begin;
send select * from t1 for update; # blocked by con1
sleep 1;
connection con3;
send flush tables with read lock; # blocked by con2
connection con1;
commit; # should not be blocked by con3
connection con2;
reap;
commit;
connection con3;
reap;
unlock tables;

# BUG#6732 FLUSH TABLES WITH READ LOCK + COMMIT hangs later FLUSH TABLES
# WITH READ LOCK

connection con2;
commit; # unlock InnoDB row locks to allow insertions
connection con1;
begin;
insert into t1 values(10);
flush tables with read lock;
connection con2;
flush tables with read lock; # bug caused hang here
unlock tables;

# BUG#7358 SHOW CREATE DATABASE fails if open transaction

begin;
select * from t1;
show create database test;
commit;

# GLR blocks new transactions
connection con1;
flush tables with read lock;
connection con2;
begin;
--send insert into t1 values (1);
connection con1;
let $wait_condition=
  select count(*) = 1 from information_schema.processlist
  where state = "Waiting for release of readlock" and
        info = "insert into t1 values (1)";
--source include/wait_condition.inc
unlock tables;
connection con2;
--reap
commit;

drop table t1;

# End of 4.1 tests
