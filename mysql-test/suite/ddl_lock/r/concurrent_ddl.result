SET DEBUG_SYNC= 'RESET';
DROP TABLE IF EXISTS t1;
CREATE TABLE t1(a INT) ENGINE=<engine_type>;
INSERT INTO t1 VALUES (1);
# Establish connection locker: the connection that locks the resource
# Establish connection waiter: the connection that waits for the resource
# Both these connections are used the same way in all the test cases
# In this test.
##
## 1.1 One connection holding a lock on a table, other performing
##     alter, handler, truncate and drop on same object
##
SET DEBUG_SYNC= 'RESET';
# Connection waiter will run setup (if any)
# Using sync_lock.inc to synchronize on 'mdl_enter_cond'
# Connection locker will lock the resource
SET DEBUG_SYNC= 'after_lock_tables_takes_lock SIGNAL locked WAIT_FOR do_unlock';
LOCK TABLES t1 READ;
# Connection waiter will wait for the resource to be locked, and then
# run the SQL that should lock.
SET DEBUG_SYNC= 'now WAIT_FOR locked';
SET DEBUG_SYNC= '<sync> SIGNAL do_unlock';
ALTER TABLE t1 ADD COLUMN (b INT);
# Connection locker will unlock the locked resources
UNLOCK TABLES;
# Connection waiter will wait for the SQL to return after the
# lock is unlocked, and run teardown if we have any
# Cleaning up in default connection
SET DEBUG_SYNC= 'RESET';
SET DEBUG_SYNC= 'RESET';
# Connection waiter will run setup (if any)
# Using sync_lock.inc to synchronize on 'mdl_enter_cond'
# Connection locker will lock the resource
SET DEBUG_SYNC= 'after_lock_tables_takes_lock SIGNAL locked WAIT_FOR do_unlock';
LOCK TABLES t1 READ;
# Connection waiter will wait for the resource to be locked, and then
# run the SQL that should lock.
SET DEBUG_SYNC= 'now WAIT_FOR locked';
SET DEBUG_SYNC= '<sync> SIGNAL do_unlock';
RENAME TABLE t1 TO t2;
# Connection locker will unlock the locked resources
UNLOCK TABLES;
# Connection waiter will wait for the SQL to return after the
# lock is unlocked, and run teardown if we have any
RENAME TABLE t2 TO t1;
# Cleaning up in default connection
SET DEBUG_SYNC= 'RESET';
SET DEBUG_SYNC= 'RESET';
# Connection waiter will run setup (if any)
HANDLER t1 OPEN;
# Using sync_lock.inc to synchronize on 'locked_external'
# Connection locker will lock the resource
SET DEBUG_SYNC= 'after_lock_tables_takes_lock SIGNAL locked WAIT_FOR do_unlock';
LOCK TABLES t1 READ;
# Connection waiter will wait for the resource to be locked, and then
# run the SQL that should lock.
SET DEBUG_SYNC= 'now WAIT_FOR locked';
SET DEBUG_SYNC= '<sync> SIGNAL do_unlock';
HANDLER t1 READ FIRST;
# Connection locker will unlock the locked resources
UNLOCK TABLES;
# Connection waiter will wait for the SQL to return after the
# lock is unlocked, and run teardown if we have any
a	b
1	NULL
HANDLER t1 CLOSE;
# Cleaning up in default connection
SET DEBUG_SYNC= 'RESET';
SET DEBUG_SYNC= 'RESET';
# Connection waiter will run setup (if any)
# Using sync_lock.inc to synchronize on 'mdl_enter_cond'
# Connection locker will lock the resource
SET DEBUG_SYNC= 'after_lock_tables_takes_lock SIGNAL locked WAIT_FOR do_unlock';
LOCK TABLES t1 READ;
# Connection waiter will wait for the resource to be locked, and then
# run the SQL that should lock.
SET DEBUG_SYNC= 'now WAIT_FOR locked';
SET DEBUG_SYNC= '<sync> SIGNAL do_unlock';
TRUNCATE TABLE t1;
# Connection locker will unlock the locked resources
UNLOCK TABLES;
# Connection waiter will wait for the SQL to return after the
# lock is unlocked, and run teardown if we have any
# Cleaning up in default connection
SET DEBUG_SYNC= 'RESET';
SET DEBUG_SYNC= 'RESET';
# Connection waiter will run setup (if any)
# Using sync_lock.inc to synchronize on 'mdl_enter_cond'
# Connection locker will lock the resource
SET DEBUG_SYNC= 'after_lock_tables_takes_lock SIGNAL locked WAIT_FOR do_unlock';
LOCK TABLES t1 READ;
# Connection waiter will wait for the resource to be locked, and then
# run the SQL that should lock.
SET DEBUG_SYNC= 'now WAIT_FOR locked';
SET DEBUG_SYNC= '<sync> SIGNAL do_unlock';
DROP TABLE t1;
# Connection locker will unlock the locked resources
UNLOCK TABLES;
# Connection waiter will wait for the SQL to return after the
# lock is unlocked, and run teardown if we have any
# Cleaning up in default connection
SET DEBUG_SYNC= 'RESET';
##
## 1.2 Two connections trying to perform alter on same table/view
##
CREATE TABLE t1(a INT, b CHAR(100) DEFAULT "test 1.2")
ENGINE=<engine_type>;
INSERT INTO t1 (a) VALUES (1), (2), (3), (4), (5);
# Switch to connection locker
SET DEBUG_SYNC= 'alter_table_before_main_binlog
                SIGNAL locked WAIT_FOR do_unlock';
# "send" next statement
ALTER TABLE t1 ADD COLUMN (c CHAR(100) DEFAULT "test 1.2 locker");
# Switch to connection waiter
SET DEBUG_SYNC= 'now WAIT_FOR locked';
SET DEBUG_SYNC= 'mdl_enter_cond SIGNAL do_unlock';
# "send" next statement
ALTER TABLE t1 ADD COLUMN (d CHAR(100) DEFAULT "test 1.2 waiter");
# Switch to connection locker
# "reap" outcome of last statement
# Switch to connection waiter
# "reap" outcome of last statement
# Switch to connection default
SET DEBUG_SYNC= 'RESET';
SELECT SUM(a) FROM t1;
SUM(a)
15
SELECT COUNT(*) FROM t1 WHERE NOT c LIKE "test 1.2 %";
COUNT(*)
0
DROP TABLE t1;
##
## 1.3 One connection creating a table, another is trying to alter it
##
CREATE TABLE t1(a INT, b INT)
ENGINE=<engine_type>;
INSERT INTO t1 VALUES (1, 2), (2, 3), (3, 4), (4, 5), (5, 6);
# Switch to connection locker
SET DEBUG_SYNC= 'after_lock_tables_takes_lock
                 SIGNAL locked WAIT_FOR do_unlock';
# "send" next statement
CREATE TABLE t2 ENGINE=<engine_type> AS SELECT *, SLEEP(1) FROM t1;
# Switch to connection waiter
SET DEBUG_SYNC= 'now WAIT_FOR locked';
SET DEBUG_SYNC= 'mdl_enter_cond SIGNAL do_unlock';
# "send" next statement
ALTER TABLE t1 ADD COLUMN (c INT);
# Switch to connection locker
# "reap" outcome of last statement
# Switch to connection waiter
# "reap" outcome of last statement
# Switch to connection default
SET DEBUG_SYNC= 'RESET';
SELECT SUM(a), SUM(b) FROM t1;
SUM(a)	SUM(b)
15	20
SELECT SUM(a), SUM(b) FROM t2;
SUM(a)	SUM(b)
15	20
DROP TABLE t1;
DROP TABLE t2;
##
## 1.4 One connection is selecting (using handler) while another is
##     altering the table (select start first)
##
CREATE TABLE t1(a INT, b INT) ENGINE=<engine_type>;
INSERT INTO t1 VALUES (1, 2), (3, 4);
# Switch to connection locker
HANDLER t1 OPEN;
SET DEBUG_SYNC= 'locked_external SIGNAL locked WAIT_FOR do_unlock';
# "send" next statement
HANDLER t1 READ FIRST;
# Switch to connection waiter
SET DEBUG_SYNC= 'now WAIT_FOR locked';
SET DEBUG_SYNC= 'mdl_enter_cond SIGNAL do_unlock';
# "send" next statement
ALTER TABLE t1 ADD COLUMN (c INT);
# Switch to connection locker
# "reap" outcome of last statement
a	b	c
1	2	NULL
HANDLER t1 CLOSE;
SELECT * FROM t1 ORDER BY a;
a	b	c
1	2	NULL
3	4	NULL
# Switch to connection waiter
# "reap" outcome of last statement
# Switch to connection locker
HANDLER t1 OPEN;
SET DEBUG_SYNC= 'locked_external SIGNAL locked WAIT_FOR do_unlock';
# "send" next statement
HANDLER t1 READ FIRST;
# Switch to connection waiter
SET DEBUG_SYNC= 'now WAIT_FOR locked';
SET DEBUG_SYNC= 'mdl_enter_cond SIGNAL do_unlock';
# "send" next statement
ALTER TABLE t1 DROP COLUMN b;
# Switch to connection locker
# "reap" outcome of last statement
a	c
1	NULL
HANDLER t1 CLOSE;
SELECT * FROM t1 ORDER BY a;
a	c
1	NULL
3	NULL
# Switch to connection waiter
# "reap" outcome of last statement
SELECT * FROM t1 ORDER BY a;
a	c
1	NULL
3	NULL
# Switch to connection default
SET DEBUG_SYNC= 'RESET';
DROP TABLE t1;
##
## 1.5 One connection selecting (using handler), while another is
##     altering the table - altering table starts first
##
CREATE TABLE t1(a INT, b CHAR(100)) ENGINE=<engine_type>;
INSERT INTO t1 (a) VALUES (10);
INSERT INTO t1 (a) VALUES (9);
INSERT INTO t1 (a) VALUES (8);
INSERT INTO t1 (a) VALUES (7);
INSERT INTO t1 (a) VALUES (6);
INSERT INTO t1 (a) VALUES (5);
INSERT INTO t1 (a) VALUES (4);
INSERT INTO t1 (a) VALUES (3);
INSERT INTO t1 (a) VALUES (2);
INSERT INTO t1 (a) VALUES (1);
# Switch to connection locker
SET DEBUG_SYNC= 'alter_table_before_main_binlog
                 SIGNAL locked WAIT_FOR do_unlock';
# "send" next statement
ALTER TABLE t1 ADD COLUMN (c CHAR(100) DEFAULT "test 1.5");
# Switch to connection waiter
SET DEBUG_SYNC= 'now WAIT_FOR locked';
SET DEBUG_SYNC= 'mdl_enter_cond SIGNAL do_unlock';
# "send" next statement
HANDLER t1 OPEN;
# Switch to connection locker
# "reap" outcome of last statement
# Switch to connection waiter
# "reap" outcome of last statement
HANDLER t1 READ FIRST;
a	b	c
10	NULL	test 1.5
HANDLER t1 CLOSE;
# Switch to connection default
SELECT SUM(a) FROM t1;
SUM(a)
55
SELECT COUNT(*) FROM t1 WHERE NOT c LIKE "test 1.5";
COUNT(*)
0
SET DEBUG_SYNC= 'RESET';
DROP TABLE t1;
##
## 1.6 Tow connections are long create/select, while another is
##     altering the table
##
# Connections locker1..locker3 will run different SQL queries, which
# will all lock on the same resource.
CREATE TABLE t1(a INT, b INT)
ENGINE=<engine_type>;
INSERT INTO t1 VALUES (1, 2), (2, 3), (3, 4), (4, 5), (5, 6);
# Switch to connection locker1
SET DEBUG_SYNC= 'after_lock_tables_takes_lock
                 SIGNAL locked WAIT_FOR do_unlock';
# "send" next statement
CREATE TABLE t2 ENGINE=<engine_type> AS SELECT *, SLEEP(1) FROM t1;
# Switch to connection locker2
# "send" next statement
CREATE TABLE t3 LIKE t1;
# Switch to connection locker3
# "send" next statement
CREATE TABLE t4 ENGINE=<engine_type> AS SELECT *, SLEEP(1) FROM t1;
# Switch to connection waiter
SET DEBUG_SYNC= 'now WAIT_FOR locked';
SET DEBUG_SYNC= 'mdl_enter_cond SIGNAL do_unlock';
# "send" next statement
ALTER TABLE t1 ADD COLUMN (c INT);
# Switch to connection locker3
# "reap" outcome of last statement
# Switch to connection locker2
# "reap" outcome of last statement
# Switch to connection locker1
# "reap" outcome of last statement
# Switch to connection waiter
# "reap" outcome of last statement
# Switch to connection default
SELECT SUM(a), SUM(b) FROM t2;
SUM(a)	SUM(b)
15	20
SELECT SUM(a), SUM(b) FROM t3;
SUM(a)	SUM(b)
NULL	NULL
SELECT SUM(a), SUM(b) FROM t4;
SUM(a)	SUM(b)
15	20
# Closing connections locker1..locker3 since they are not used any more
SET DEBUG_SYNC= 'RESET';
DROP TABLE t1;
DROP TABLE t2;
DROP TABLE t3;
DROP TABLE t4;
##
## 1.7 Both connections trying to rename the same table/view
##     (including alter ... rename command)
##
CREATE TABLE t1(a INT, b CHAR(100))
ENGINE=<engine_type>;
# Switch to connection locker
SET DEBUG_SYNC= 'after_lock_tables_takes_lock
                 SIGNAL locked WAIT_FOR do_unlock';
# "send" next statement
ALTER TABLE t1 RENAME t2;
# Switch to connection waiter
SET DEBUG_SYNC= 'now WAIT_FOR locked';
SET DEBUG_SYNC= 'after_start_ddl SIGNAL do_unlock';
# "send" next statement
ALTER TABLE t2 RENAME t3;
# Switch to connection locker
# "reap" outcome of last statement
# Switch to connection waiter
# "reap" outcome of last statement
# Switch to connection default
SELECT SUM(a) FROM t3;
SUM(a)
NULL
SELECT COUNT(*) FROM t3;
COUNT(*)
0
SET DEBUG_SYNC= 'RESET';
DROP TABLE t3;
##
## 1.8a Use list of tables in DROP TABLE and RENAME TABLE statements
##
CREATE TABLE t1(a INT) ENGINE=<engine_type>;
INSERT INTO t1 VALUES (1);
CREATE TABLE t_t1(a INT) ENGINE=<engine_type>;
INSERT INTO t_t1 VALUES (1);
SET DEBUG_SYNC= 'RESET';
# Connection waiter will run setup (if any)
# Using sync_lock.inc to synchronize on 'mdl_enter_cond'
# Connection locker will lock the resource
SET DEBUG_SYNC= 'after_lock_tables_takes_lock SIGNAL locked WAIT_FOR do_unlock';
LOCK TABLES t1 READ;
# Connection waiter will wait for the resource to be locked, and then
# run the SQL that should lock.
SET DEBUG_SYNC= 'now WAIT_FOR locked';
SET DEBUG_SYNC= '<sync> SIGNAL do_unlock';
RENAME TABLE t1 TO t2, t_t1 TO t3;
# Connection locker will unlock the locked resources
UNLOCK TABLES;
# Connection waiter will wait for the SQL to return after the
# lock is unlocked, and run teardown if we have any
RENAME TABLE t2 TO t1, t3 TO t_t1;
# Cleaning up in default connection
SET DEBUG_SYNC= 'RESET';
SET DEBUG_SYNC= 'RESET';
# Connection waiter will run setup (if any)
# Using sync_lock.inc to synchronize on 'mdl_enter_cond'
# Connection locker will lock the resource
SET DEBUG_SYNC= 'after_lock_tables_takes_lock SIGNAL locked WAIT_FOR do_unlock';
LOCK TABLES t1 READ;
# Connection waiter will wait for the resource to be locked, and then
# run the SQL that should lock.
SET DEBUG_SYNC= 'now WAIT_FOR locked';
SET DEBUG_SYNC= '<sync> SIGNAL do_unlock';
DROP TABLE t1, t_t1;
# Connection locker will unlock the locked resources
UNLOCK TABLES;
# Connection waiter will wait for the SQL to return after the
# lock is unlocked, and run teardown if we have any
# Cleaning up in default connection
SET DEBUG_SYNC= 'RESET';
##
## 1.9 Two connections trying to alter the same stored procedure
##     and function
##
# Switch to connection default
CREATE TABLE t1 (id INT PRIMARY KEY, b CHAR(100) DEFAULT "initial value")
ENGINE=<engine_type>;
CREATE PROCEDURE t_proc ()
BEGIN
SELECT * FROM t1;
END|
# Switch to connection locker
SET DEBUG_SYNC= 'after_lock_tables_takes_lock
                 SIGNAL locked WAIT_FOR do_unlock';
# "send" next statement
ALTER PROCEDURE t_proc COMMENT 'Now with a comment from conn lock 1.9';
# Switch to connection waiter
SET DEBUG_SYNC= 'now WAIT_FOR locked';
SET DEBUG_SYNC= 'wait_for_lock SIGNAL do_unlock';
# "send" next statement
ALTER PROCEDURE t_proc COMMENT 'Now with a comment from conn waiter 1.9';
# Switch to connection locker
# "reap" outcome of last statement
# Switch to connection waiter
# "reap" outcome of last statement
# Switch to connection default
SET DEBUG_SYNC= 'RESET';
DROP PROCEDURE t_proc;
CREATE FUNCTION t_func (s CHAR(20)) RETURNS CHAR(30) DETERMINISTIC
RETURN CONCAT('Hello, ', s, '!');
# Switch to connection locker
SET DEBUG_SYNC= 'after_lock_tables_takes_lock
                 SIGNAL locked WAIT_FOR do_unlock';
# "send" next statement
ALTER FUNCTION t_func COMMENT 'Now with a comment from conn locker 1.9';
# Switch to connection waiter
SET DEBUG_SYNC= 'now WAIT_FOR locked';
SET DEBUG_SYNC= 'wait_for_lock SIGNAL do_unlock';
# "send" next statement
ALTER FUNCTION t_func COMMENT 'Now with a comment from conn waiter 1.9';
# Switch to connection locker
# "reap" outcome of last statement
# Switch to connection waiter
# "reap" outcome of last statement
# Switch to connection default
SET DEBUG_SYNC= 'RESET';
DROP FUNCTION t_func;
DROP TABLE t1;
##
## 1.10 One Connection altering a stored procedure/function, while
##      the other is dropping it.
##
CREATE TABLE t1 (id INT PRIMARY KEY, b CHAR(100) DEFAULT "initial value")
ENGINE=<engine_type>;
CREATE PROCEDURE t_proc ()
BEGIN
SELECT * FROM t1;
END|
# Switch to connection locker
SET DEBUG_SYNC= 'after_lock_tables_takes_lock
                 SIGNAL locked WAIT_FOR do_unlock';
# "send" next statement
ALTER PROCEDURE t_proc COMMENT 'Now with a comment from conn lock 1.10';
# Switch to connection waiter
SET DEBUG_SYNC= 'now WAIT_FOR locked';
SET DEBUG_SYNC= 'wait_for_lock SIGNAL do_unlock';
# "send" next statement
DROP PROCEDURE t_proc;
# Switch to connection locker
# "reap" outcome of last statement
ERROR 42000: PROCEDURE test.t_proc does not exist
# Switch to connection waiter
# "reap" outcome of last statement
# Switch to connection default
CREATE FUNCTION t_func (s CHAR(20)) RETURNS CHAR(30) DETERMINISTIC
RETURN CONCAT('Hello, ', s, '!');
# Switch to connection locker
SET DEBUG_SYNC= 'after_lock_tables_takes_lock
                 SIGNAL locked WAIT_FOR do_unlock';
# "send" next statement
ALTER FUNCTION t_func COMMENT 'Now with a comment from conn lock 1.10';
# Switch to connection waiter
SET DEBUG_SYNC= 'now WAIT_FOR locked';
SET DEBUG_SYNC= 'wait_for_lock SIGNAL do_unlock';
# "send" next statement
DROP FUNCTION t_func;
# Switch to connection locker
# "reap" outcome of last statement
ERROR 42000: FUNCTION test.t_func does not exist
# Switch to connection waiter
# "reap" outcome of last statement
# Switch to connection default
SET DEBUG_SYNC= 'RESET';
DROP table t1;
##
## 1.11, 1.12 and 1.13 - ALTER TABLE and TRUNCATE TABLE simoultaniously
##
CREATE TABLE t1(a INT, b CHAR(20) DEFAULT "test 1.11")
ENGINE=<engine_type>;
INSERT INTO t1 (a) VALUES (1);
# Switch to connection locker
SET DEBUG_SYNC= '<sync> SIGNAL locked WAIT_FOR do_unlock';
# "send" next statement
TRUNCATE TABLE t1;
# Switch to connection waiter
SET DEBUG_SYNC= 'now WAIT_FOR locked';
SET DEBUG_SYNC= '<sync2> SIGNAL do_unlock';
# "send" next statement
ALTER TABLE t1 ADD COLUMN (c INT);
# Switch to connection locker
# "reap" outcome of last statement
# Switch to connection waiter
# "reap" outcome of last statement
# Switch to connection default
SET DEBUG_SYNC= 'RESET';
# Switch to connection locker
SET DEBUG_SYNC= 'after_lock_tables_takes_lock
                 SIGNAL locked WAIT_FOR do_unlock';
# "send" next statement
ALTER TABLE t1 ADD COLUMN (d INT);
# Switch to connection waiter
SET DEBUG_SYNC= 'now WAIT_FOR locked';
SET DEBUG_SYNC= '<sync3> SIGNAL do_unlock';
# "send" next statement
TRUNCATE TABLE t1;
# Switch to connection locker
# "reap" outcome of last statement
# Switch to connection waiter
# "reap" outcome of last statement
# Switch to connection default
SET DEBUG_SYNC= 'RESET';
DROP TABLE t1;
##
## 1.14 Two connections are trying to alter the same event.
##
CREATE EVENT ev1 ON SCHEDULE AT CURRENT_TIMESTAMP + INTERVAL 1 HOUR DO
SELECT MOD(29,9);
# Switch to connection locker
SET DEBUG_SYNC= 'locked_external SIGNAL locked WAIT_FOR do_unlock';
# "send" next statement
ALTER EVENT ev1 ON SCHEDULE EVERY 12 HOUR
STARTS CURRENT_TIMESTAMP + INTERVAL 1 HOUR;
# Switch to connection waiter
SET DEBUG_SYNC= 'now WAIT_FOR locked';
SET DEBUG_SYNC= 'after_lock_tables_takes_lock SIGNAL do_unlock';
# "send" next statement
ALTER EVENT ev1 ON SCHEDULE EVERY 4 HOUR
STARTS CURRENT_TIMESTAMP + INTERVAL 4 HOUR;
# Switch to connection locker
# "reap" outcome of last statement
# Switch to connection waiter
# "reap" outcome of last statement
# Switch to connection default
SET DEBUG_SYNC= 'RESET';
DROP EVENT ev1;
# Clean up connections
