###############################################################################
# Author: Hema
# Date: 2008-04-01
# Purpose: Verify Online capability during differnt phases of BACKUP database
# operation.
# We will ensure that Ongoing transactions are not affected by Backup Database
# command.
# To perform this test we need backup and DML operations going in parallel.
# We can make use of sync points to pause BACKUP database at different stages
# and execute DML statements. Further we can confirm that the BACKUP database
# operation is completed and the DML executed after 'validity point of time'
# aren't included in the backup.
# We establish multiple connections and for concurrency we use Send and Reap
# commands where required for statements that are blocked.
# SEND issues a statement and does not wait for the result.
# REAP waits for and returns the result of the statement issued by SEND.
#
# Breakpoints Usage:
# before_backup_data_init, before_backup_data_prepare, before_backup_command,
# before_backup_meta, before_backup_data are the Breakpoints that occur
# before Validity point of time.
#
# before_backup_data_init occurs at the start of INITIALIZE phase.
# before_backup_data_prepare occurs at the start of PREPARE phase.
# before_backup_command occurs at the start of BACKUP Operation.
# before_backup_meta occurs before the call to write metadata.
# before_backup_data occurs before the call to write table data.
#
# before_backup_data_lock, before_backup_data_unlock,
# before_backup_data_finish and before_backup_done are the breakpoints
# that occurs after validity point of time. The DML executed after 
# 'validity point of time' aren't included in the backup.
#
# before_backup_data_lock occurs before the engines are locked.
# before_backup_data_unlock occurs before the engines are unlocked.
# before_backup_data_finish occurs before the final data saving.
# before_backup_done occurs at the end of the backup statement.
###############################################################################
--source include/have_innodb.inc
--source include/have_debug_sync.inc
--source include/not_embedded.inc

#
# Preparatory cleanup.
#
--disable_warnings
# Initialize the debug sync facility.
SET DEBUG_SYNC= 'RESET';
DROP DATABASE IF EXISTS bup_online;
--error 0,1
--remove_file $MYSQLTEST_VARDIR/master-data/bup_online.bak;
--enable_warnings

##############################################################
--echo
--echo starting the test for backup
--echo
##############################################################

CREATE DATABASE bup_online;

--echo Establishing connections
--echo ** con1 to perform BACKUP AND RESTORE**
--echo ** con2 and con2a to do INSERTS**
--echo ** con3 to synchronize with BACKUP
--echo ** con4 to do UPDATES**
--echo ** con5 to do DELETES**
--echo ** con6 to check table contents**

#
# Set the startup database for all connections to bup_online.
#
connect (con1,localhost,root,,bup_online);
connect (con2,localhost,root,,bup_online);
connect (con2a,localhost,root,,bup_online);
connect (con3,localhost,root,,bup_online);
connect (con4,localhost,root,,bup_online);
connect (con5,localhost,root,,bup_online);
connect (con6,localhost,root,,bup_online);

#
# Create table and load with data.
#
--echo
--echo con1: ***Creating Tables***
connection con1;

CREATE TABLE t1(id int, details char(30))ENGINE=INNODB;
INSERT INTO t1 VALUES(1,'testing1'),(2,'testing2'),(3,'testing3'),
  (4,'testing4'),(5,'testing5'),(6,'testing6'),(7,'tesing7'),(8,'testing8'),
  (9,'testing9'),(10,'testing10'),(11,'testing11'),(12,'testing12');

CREATE TABLE t2(id int, info char(30))ENGINE=INNODB;
INSERT INTO t2 VALUES(201, 'aa1'),(202,'aa2');

CREATE TABLE t3(id int, name char(20))ENGINE=INNODB;
INSERT INTO t3 VALUES(1,'xx1'),(2,'xx2'),(3,'xx3'),(4,'xx4'),(5,'xx5');

SELECT COUNT(*) FROM t1;
SELECT COUNT(*) FROM t2;
SELECT COUNT(*) FROM t3;


--echo
--echo **TEST1**
################Test1##############################
##use of Breakpoint before_backup_data_init       #
###################################################

#################
#BACKUP DATABASE#
#################

--echo
--echo con1: Starting Backup Data
connection con1;
# Activate the sync point for BACKUP.
# When BACKUP reaches the sync point it emits the signal bup_sync
# and waits for another thread to emit the signal bup_finish.
SET DEBUG_SYNC= 'before_backup_data_init SIGNAL bup_sync
                 WAIT_FOR bup_finish';
send BACKUP DATABASE bup_online TO 'bup_online.bak';

--echo
--echo con3: Waiting for BACKUP to reach the breakpoint
connection con3;
# If BACKUP did already reach its sync point, then the signal is already
# present. If not, we wait until BACKUP emits it.
SET DEBUG_SYNC= 'now WAIT_FOR bup_sync';

#############
#INSERT DATA#
#############

--echo
--echo con2: Inserting Data
connection con2;
INSERT INTO t1 VALUES(100,'new value added100');
INSERT INTO t1 VALUES(101,'new value added101');
INSERT INTO t1 VALUES(102,'new value added102');

#############
#UPDATE DATA#
#############

--echo
--echo con4: Updating Data
connection con4;
UPDATE t2 SET info='updated values1' WHERE id=201;
UPDATE t2 SET  info='updated values2' WHERE id=202;

#############
#Delete Data#
#############

--echo
--echo con5: Deleting Data
connection con5;
DELETE FROM t1 WHERE id=11;
DELETE FROM t1 WHERE id=12;

--echo
--echo con3: Signalling that BACKUP can finish
connection con3;
SET DEBUG_SYNC= 'now SIGNAL bup_finish';

--echo
--echo con1: Fetching result of BACKUP
connection con1;
--replace_column 1 #
reap;

--echo
--echo con2: Inserting Data
connection  con2;
INSERT INTO t1 VALUES(500,'online500');
INSERT INTO t1 VALUES(600,'online600');

--echo
--echo con4: Updating Data
connection con4;
UPDATE t1 SET details='ONLINE1' WHERE id=10;

--echo
--echo con5: Deleting Data
connection con5;
DELETE FROM t2 WHERE id=201;

--echo
--echo con6: **Checking the Data Contents before Restore**
connection con6;
SELECT * FROM t1;
SELECT COUNT(*) FROM t1;
SELECT * FROM t2;
SELECT  COUNT(*) FROM t2;

##################
#RESTORE DATABASE#
##################

--echo
--echo con1: Dropping the database
connection con1;
DROP DATABASE bup_online;

--echo con1: Restoring the database
--replace_column 1 #
RESTORE FROM 'bup_online.bak';

#check data contents after Restore.
--echo
--echo *** RESULT AFTER RESTORE ***
--echo

SELECT * FROM t1;
SELECT COUNT(*) FROM t1;
SELECT * FROM t2;
SELECT  COUNT(*) FROM t2;

remove_file $MYSQLTEST_VARDIR/master-data/bup_online.bak;


--echo
--echo **TEST2**
################Test2##############################
##use of Breakpoint before_backup_data_prepare    #
###################################################

--echo
--echo con1: Starting Backup Data
connection con1;
# Activate the sync point for BACKUP.
# When BACKUP reaches the sync point it emits the signal bup_sync
# and waits for another thread to emit the signal bup_finish.
SET DEBUG_SYNC= 'before_backup_data_prepare SIGNAL bup_sync
                 WAIT_FOR bup_finish';
send BACKUP DATABASE bup_online TO 'bup_online1.bak';

--echo
--echo con3: Waiting for BACKUP to reach the breakpoint
connection con3;
# If BACKUP did already reach its sync point, then the signal is already
# present. If not, we wait until BACKUP emits it.
SET DEBUG_SYNC= 'now WAIT_FOR bup_sync';

#############
#INSERT DATA#
#############

--echo
--echo con2: Inserting Data
connection con2;
INSERT INTO t1 VALUES(103,'new value added103');
INSERT INTO t2 VALUES(203,'Updated Values3');

#############
#UPDATE DATA#
#############

--echo
--echo con4: Updating Data
connection con4;
UPDATE t1 SET details='ONLINETEST' WHERE id=10;

#############
#Delete Data#
#############

--echo
--echo con5: Deleting Data
connection con5;
DELETE FROM t3 WHERE id=5;

--echo
--echo con3: Signalling that BACKUP can finish
connection con3;
SET DEBUG_SYNC= 'now SIGNAL bup_finish';

--echo
--echo con1: Fetching result of BACKUP
connection con1;
--replace_column 1 #
reap;

--echo
--echo con2: Inserting Data
connection  con2;
INSERT INTO t1 VALUES(700,'online700');

--echo
--echo con4: Updating Data
connection con4;
UPDATE t3 SET name='yy' WHERE id=3;

--echo
--echo con6: **Checking the Data Contents before Restore**
connection con6;
SELECT * FROM t1;
SELECT COUNT(*) FROM t1;
SELECT * FROM t2;
SELECT  COUNT(*) FROM t2;
SELECT *FROM t3;
SELECT  COUNT(*) FROM t3;

##################
#RESTORE DATABASE#
##################

--echo
--echo con1: Dropping the database
connection con1;
DROP DATABASE bup_online;

--echo con1: Restoring the database
--replace_column 1 #
RESTORE FROM 'bup_online1.bak';

#check data contents after Restore.
--echo
--echo *** RESULT AFTER RESTORE ***
--echo

SELECT * FROM t1;
SELECT COUNT(*) FROM t1;
SELECT * FROM t2;
SELECT  COUNT(*) FROM t2;
SELECT *FROM t3;
SELECT  COUNT(*) FROM t3;

remove_file $MYSQLTEST_VARDIR/master-data/bup_online1.bak;


--echo
--echo **TEST3**
################Test3##############################
##use of Breakpoint before_backup_command         #
###################################################

--echo
--echo con1: Starting Backup Data
connection con1;
# Activate the sync point for BACKUP.
# When BACKUP reaches the sync point it emits the signal bup_sync
# and waits for another thread to emit the signal bup_finish.
SET DEBUG_SYNC= 'before_backup_command SIGNAL bup_sync
                 WAIT_FOR bup_finish';
send BACKUP DATABASE bup_online TO 'bup_online.bak';

--echo
--echo con3: Waiting for BACKUP to reach the breakpoint
connection con3;
# If BACKUP did already reach its sync point, then the signal is already
# present. If not, we wait until BACKUP emits it.
SET DEBUG_SYNC= 'now WAIT_FOR bup_sync';

#############
#INSERT DATA#
#############

--echo
--echo con2: Inserting Data
connection con2;
INSERT INTO t1 VALUES(104,'new value added103');
INSERT INTO t2 VALUES(204,'Updated Values3');

#############
#UPDATE DATA#
#############

--echo
--echo con4: Updating Data
connection con4;
UPDATE t1 SET details='ONLINETEST1' WHERE id=9;

#############
#Delete Data#
#############

--echo
--echo con5: Deleting Data
connection con5;
DELETE FROM t3 WHERE id=4;

--echo
--echo con3: Signalling that BACKUP can finish
connection con3;
SET DEBUG_SYNC= 'now SIGNAL bup_finish';

--echo
--echo con1: Fetching result of BACKUP
connection con1;
--replace_column 1 #
reap;

--echo
--echo con2: Inserting Data
connection  con2;
INSERT INTO t1 VALUES(800,'online800');

--echo
--echo con4: Updating Data
connection con4;
UPDATE t3 SET name='zz' WHERE id=2;

--echo
--echo con6: **Checking the Data Contents before Restore**
connection con6;
SELECT * FROM t1;
SELECT COUNT(*) FROM t1;
SELECT * FROM t2;
SELECT  COUNT(*) FROM t2;
SELECT *FROM t3;
SELECT  COUNT(*) FROM t3;

##################
#RESTORE DATABASE#
##################

--echo
--echo con1: Dropping the database
connection con1;
DROP DATABASE bup_online;

--echo con1: Restoring the database
--replace_column 1 #
RESTORE FROM 'bup_online.bak';

#check data contents after Restore.
--echo
--echo *** RESULT AFTER RESTORE ***
--echo

SELECT * FROM t1;
SELECT COUNT(*) FROM t1;
SELECT * FROM t2;
SELECT  COUNT(*) FROM t2;
SELECT *FROM t3;
SELECT  COUNT(*) FROM t3;

remove_file $MYSQLTEST_VARDIR/master-data/bup_online.bak;


--echo
--echo **TEST4**
################Test4##############################
##use of Breakpoint before_backup_meta            #
###################################################

--echo
--echo con1: Starting Backup Data
connection con1;
# Activate the sync point for BACKUP.
# When BACKUP reaches the sync point it emits the signal bup_sync
# and waits for another thread to emit the signal bup_finish.
SET DEBUG_SYNC= 'before_backup_meta SIGNAL bup_sync
                 WAIT_FOR bup_finish';
send BACKUP DATABASE bup_online TO 'bup_online.bak';

--echo
--echo con3: Waiting for BACKUP to reach the breakpoint
connection con3;
# If BACKUP did already reach its sync point, then the signal is already
# present. If not, we wait until BACKUP emits it.
SET DEBUG_SYNC= 'now WAIT_FOR bup_sync';

#############
#INSERT DATA#
#############

--echo
--echo con2: Inserting Data
connection con2;
INSERT INTO t1 VALUES(105,'new value added105');
INSERT INTO t2 VALUES(205,'Updated Values5');

#############
#UPDATE DATA#
#############

--echo
--echo con4: Updating Data
connection con4;
UPDATE t1 SET details='ONLINETEST1' WHERE id=8;

#############
#Delete Data#
#############

--echo
--echo con5: Deleting Data
connection con5;
DELETE FROM t3 WHERE id=3;

--echo
--echo con3: Signalling that BACKUP can finish
connection con3;
SET DEBUG_SYNC= 'now SIGNAL bup_finish';

--echo
--echo con1: Fetching result of BACKUP
connection con1;
--replace_column 1 #
reap;

--echo
--echo con2: Inserting Data
connection  con2;
INSERT INTO t1 VALUES(900,'online900');

--echo
--echo con4: Updating Data
connection con4;
UPDATE t3 SET name='tt' WHERE id=2;

--echo
--echo con6: **Checking the Data Contents before Restore**
connection con6;
SELECT * FROM t1;
SELECT COUNT(*) FROM t1;
SELECT * FROM t2;
SELECT  COUNT(*) FROM t2;
SELECT *FROM t3;
SELECT  COUNT(*) FROM t3;

##################
#RESTORE DATABASE#
##################

--echo
--echo con1: Dropping the database
connection con1;
DROP DATABASE bup_online;

--echo con1: Restoring the database
--replace_column 1 #
RESTORE FROM 'bup_online.bak';

#check data contents after Restore.
--echo
--echo *** RESULT AFTER RESTORE ***
--echo

SELECT * FROM t1;
SELECT COUNT(*) FROM t1;
SELECT * FROM t2;
SELECT  COUNT(*) FROM t2;
SELECT *FROM t3;
SELECT  COUNT(*) FROM t3;

remove_file $MYSQLTEST_VARDIR/master-data/bup_online.bak;


--echo
--echo **TEST5**
################Test5##############################
##use of Breakpoint before_backup_data            #
###################################################

--echo
--echo con1: Starting Backup Data
connection con1;
# Activate the sync point for BACKUP.
# When BACKUP reaches the sync point it emits the signal bup_sync
# and waits for another thread to emit the signal bup_finish.
SET DEBUG_SYNC= 'before_backup_data SIGNAL bup_sync
                 WAIT_FOR bup_finish';
send BACKUP DATABASE bup_online TO 'bup_online.bak';

--echo
--echo con3: Waiting for BACKUP to reach the breakpoint
connection con3;
# If BACKUP did already reach its sync point, then the signal is already
# present. If not, we wait until BACKUP emits it.
SET DEBUG_SYNC= 'now WAIT_FOR bup_sync';

#############
#INSERT DATA#
#############

--echo
--echo con2: Inserting Data
connection con2;
INSERT INTO t1 VALUES(106,'new value added106');
INSERT INTO t2 VALUES(206,'Updated Values6');

#############
#UPDATE DATA#
#############

--echo
--echo con4: Updating Data
connection con4;
UPDATE t1 SET details='ONLINETEST1' WHERE id=7;

#############
#Delete Data#
#############

--echo
--echo con5: Deleting Data
connection con5;
DELETE FROM t3 WHERE id=2;

--echo
--echo con3: Signalling that BACKUP can finish
connection con3;
SET DEBUG_SYNC= 'now SIGNAL bup_finish';

--echo
--echo con1: Fetching result of BACKUP
connection con1;
--replace_column 1 #
reap;

--echo
--echo con2: Inserting Data
connection  con2;
INSERT INTO t1 VALUES(1000,'online1000');

--echo
--echo con4: Updating Data
connection con4;
UPDATE t3 SET name='uu' WHERE id=1;

--echo
--echo con6: **Checking the Data Contents before Restore**
connection con6;
SELECT * FROM t1;
SELECT COUNT(*) FROM t1;
SELECT * FROM t2;
SELECT  COUNT(*) FROM t2;
SELECT *FROM t3;
SELECT  COUNT(*) FROM t3;

##################
#RESTORE DATABASE#
##################

--echo
--echo con1: Dropping the database
connection con1;
DROP DATABASE bup_online;

--echo con1: Restoring the database
--replace_column 1 #
RESTORE FROM 'bup_online.bak';

#check data contents after Restore.
--echo
--echo *** RESULT AFTER RESTORE ***
--echo

SELECT * FROM t1;
SELECT COUNT(*) FROM t1;
SELECT * FROM t2;
SELECT  COUNT(*) FROM t2;
SELECT *FROM t3;
SELECT  COUNT(*) FROM t3;

remove_file $MYSQLTEST_VARDIR/master-data/bup_online.bak;


--echo
--echo **TEST6**
################Test6##############################
##use of Breakpoint before_backup_data_lock       #
###################################################

# In this test we need to send the DML statements to the background.
# They block in wait_if_global_read_lock.
# BACKUP is blocked at the sync point "data_lock", which occurs after
# block_commits(), which locks the global read lock, and before
# unblock_commits(), which releases the global read lock.

--echo
--echo con1: Starting Backup Data
connection con1;
# Activate the sync point for BACKUP.
# When BACKUP reaches the sync point it emits the signal bup_sync
# and waits for another thread to emit the signal bup_finish.
SET DEBUG_SYNC= 'before_backup_data_lock SIGNAL bup_sync
                 WAIT_FOR bup_finish';
send BACKUP DATABASE bup_online TO 'bup_online.bak';

--echo
--echo con3: Waiting for BACKUP to reach the breakpoint
connection con3;
# If BACKUP did already reach its sync point, then the signal is already
# present. If not, we wait until BACKUP emits it.
SET DEBUG_SYNC= 'now WAIT_FOR bup_sync';

#############
#INSERT DATA#
#############

--echo
--echo con2: Starting Insert Data
connection con2;
send INSERT INTO t1 VALUES(107,'new value added107');

--echo
--echo con2a: Starting Insert Data
connection con2a;
send INSERT INTO t2 VALUES(207,'Updated Values7');

#############
#UPDATE DATA#
#############

--echo
--echo con4: Starting Update data
connection con4;
send UPDATE t1 SET details='ONLINETEST1' WHERE id=6;

#############
#Delete Data#
#############

--echo
--echo con5: Starting Delete data
connection con5;
send DELETE FROM t3 WHERE id=1;

--echo
--echo con3: Signalling that BACKUP can finish
connection con3;
SET DEBUG_SYNC= 'now SIGNAL bup_finish';

--echo
--echo con1: Fetching result of BACKUP
connection con1;
--replace_column 1 #
reap;

--echo
--echo con2: Fetching result of INSERT and Insert more data
connection  con2;
reap;
INSERT INTO t1 VALUES(1010,'online1010');

--echo
--echo con2a: Fetching result of INSERT
connection  con2a;
reap;

--echo
--echo con4: Fetching result of UPDATE and Update more data
connection con4;
reap;
UPDATE t2 SET info='t2 updated1' WHERE id=205;

--echo
--echo con5: Fetching result of DELETE
connection con5;
reap;

--echo
--echo con6: **Checking the Data Contents before Restore**
connection con6;
SELECT * FROM t1;
SELECT COUNT(*) FROM t1;
SELECT * FROM t2;
SELECT  COUNT(*) FROM t2;
SELECT *FROM t3;
SELECT  COUNT(*) FROM t3;

##################
#RESTORE DATABASE#
##################

--echo
--echo con1: Dropping the database
connection con1;
DROP DATABASE bup_online;

--echo con1: Restoring the database
--replace_column 1 #
RESTORE FROM 'bup_online.bak';

#check data contents after Restore.
--echo
--echo *** RESULT AFTER RESTORE ***
--echo

SELECT * FROM t1;
SELECT COUNT(*) FROM t1;
SELECT * FROM t2;
SELECT  COUNT(*) FROM t2;
SELECT *FROM t3;
SELECT  COUNT(*) FROM t3;

remove_file $MYSQLTEST_VARDIR/master-data/bup_online.bak;


--echo
--echo **TEST7**
################Test7##############################
##use of Breakpoint before_backup_data_unlock     #
###################################################

# In this test we need to send the DML statements to the background.
# They block in wait_if_global_read_lock.
# BACKUP is blocked at the sync point "data_unlock", which occurs before
# unblock_commits(), which releases the global read lock and after
# block_commits(), which locks the global read lock.

--echo
--echo con1: Starting Backup Data
connection con1;
# Activate the sync point for BACKUP.
# When BACKUP reaches the sync point it emits the signal bup_sync
# and waits for another thread to emit the signal bup_finish.
SET DEBUG_SYNC= 'before_backup_data_unlock SIGNAL bup_sync
                 WAIT_FOR bup_finish';
send BACKUP DATABASE bup_online TO 'bup_online.bak';

--echo
--echo con3: Waiting for BACKUP to reach the breakpoint
connection con3;
# If BACKUP did already reach its sync point, then the signal is already
# present. If not, we wait until BACKUP emits it.
SET DEBUG_SYNC= 'now WAIT_FOR bup_sync';

#############
#INSERT DATA#
#############

--echo
--echo con2: Starting Insert Data
connection con2;
send INSERT INTO t1 VALUES(108,'new value added108');

--echo
--echo con2a: Starting Insert Data
connection con2a;
send INSERT INTO t3 VALUES(20,'zz20');

#############
#UPDATE DATA#
#############

--echo
--echo con4: Starting Update data
connection con4;
send UPDATE t1 SET details='ONLINETEST1' WHERE id=4;

#############
#Delete Data#
#############

--echo
--echo con5: Starting Delete data
connection con5;
send DELETE FROM t3 WHERE id=1;

--echo
--echo con3: Signalling that BACKUP can finish
connection con3;
SET DEBUG_SYNC= 'now SIGNAL bup_finish';

--echo
--echo con1: Fetching result of BACKUP
connection con1;
--replace_column 1 #
reap;

--echo
--echo con2: Fetching result of INSERT and Insert more data
connection  con2;
reap;
INSERT INTO t1 VALUES(1020,'online1020');

--echo
--echo con2a: Fetching result of INSERT
connection  con2a;
reap;

--echo
--echo con4: Fetching result of UPDATE and Update more data
connection con4;
reap;
UPDATE t2 SET info='t2 updated2' WHERE id=206;

--echo
--echo con5: Fetching result of DELETE
connection con5;
reap;

--echo
--echo con6: **Checking the Data Contents before Restore**
connection con6;
SELECT * FROM t1;
SELECT COUNT(*) FROM t1;
SELECT * FROM t2;
SELECT  COUNT(*) FROM t2;
SELECT *FROM t3;
SELECT  COUNT(*) FROM t3;

##################
#RESTORE DATABASE#
##################

--echo
--echo con1: Dropping the database
connection con1;
DROP DATABASE bup_online;

--echo con1: Restoring the database
--replace_column 1 #
RESTORE FROM 'bup_online.bak';

#check data contents after Restore.
--echo
--echo *** RESULT AFTER RESTORE ***
--echo

SELECT * FROM t1;
SELECT COUNT(*) FROM t1;
SELECT * FROM t2;
SELECT  COUNT(*) FROM t2;
SELECT *FROM t3;
SELECT  COUNT(*) FROM t3;


remove_file $MYSQLTEST_VARDIR/master-data/bup_online.bak;


--echo
--echo **TEST8**
################Test8##############################
##use of Breakpoint before_backup_data_finish     #
###################################################

--echo
--echo con1: Starting Backup Data
connection con1;
# Activate the sync point for BACKUP.
# When BACKUP reaches the sync point it emits the signal bup_sync
# and waits for another thread to emit the signal bup_finish.
SET DEBUG_SYNC= 'before_backup_data_finish SIGNAL bup_sync
                 WAIT_FOR bup_finish';
send BACKUP DATABASE bup_online TO 'bup_online.bak';

--echo
--echo con3: Waiting for BACKUP to reach the breakpoint
connection con3;
# If BACKUP did already reach its sync point, then the signal is already
# present. If not, we wait until BACKUP emits it.
SET DEBUG_SYNC= 'now WAIT_FOR bup_sync';

#############
#INSERT DATA#
#############

--echo
--echo con2: Inserting Data
connection con2;
INSERT INTO t1 VALUES(109,'new value added109');
INSERT INTO t3 VALUES(30,'zz30');

#############
#UPDATE DATA#
#############

--echo
--echo con4: Updating Data
connection con4;
UPDATE t1 SET details='ONLINETEST1' WHERE id=3;

#############
#Delete Data#
#############

--echo
--echo con5: Deleting Data
connection con5;
DELETE FROM t3 WHERE id=20;

--echo
--echo con3: Signalling that BACKUP can finish
connection con3;
SET DEBUG_SYNC= 'now SIGNAL bup_finish';

--echo
--echo con1: Fetching result of BACKUP
connection con1;
--replace_column 1 #
reap;

--echo
--echo con2: Inserting Data
connection  con2;
INSERT INTO t1 VALUES(1030,'online1030');

--echo
--echo con4: Updating Data
connection con4;
UPDATE t2 SET info='t2 updated3' WHERE id=207;

--echo
--echo con6: **Checking the Data Contents before Restore**
connection con6;
SELECT * FROM t1;
SELECT COUNT(*) FROM t1;
SELECT * FROM t2;
SELECT  COUNT(*) FROM t2;
SELECT *FROM t3;
SELECT  COUNT(*) FROM t3;

##################
#RESTORE DATABASE#
##################

--echo
--echo con1: Dropping the database
connection con1;
DROP DATABASE bup_online;

--echo con1: Restoring the database
--replace_column 1 #
RESTORE FROM 'bup_online.bak';

#check data contents after Restore.
--echo
--echo *** RESULT AFTER RESTORE ***
--echo

SELECT * FROM t1;
SELECT COUNT(*) FROM t1;
SELECT * FROM t2;
SELECT  COUNT(*) FROM t2;
SELECT *FROM t3;
SELECT  COUNT(*) FROM t3;

remove_file $MYSQLTEST_VARDIR/master-data/bup_online.bak;


--echo
--echo **TEST9**
################Test9##############################
##use of Breakpoint before_backup_done            #
###################################################

--echo
--echo con1: Starting Backup Data
connection con1;
# Activate the sync point for BACKUP.
# When BACKUP reaches the sync point it emits the signal bup_sync
# and waits for another thread to emit the signal bup_finish.
SET DEBUG_SYNC= 'before_backup_done SIGNAL bup_sync
                 WAIT_FOR bup_finish';
send BACKUP DATABASE bup_online TO 'bup_online.bak';

--echo
--echo con3: Waiting for BACKUP to reach the breakpoint
connection con3;
# If BACKUP did already reach its sync point, then the signal is already
# present. If not, we wait until BACKUP emits it.
SET DEBUG_SYNC= 'now WAIT_FOR bup_sync';

#############
#INSERT DATA#
#############

--echo
--echo con2: Inserting Data
connection con2;
INSERT INTO t1 VALUES(110,'new value added110');
INSERT INTO t3 VALUES(40,'zz40');

#############
#UPDATE DATA#
#############

--echo
--echo con4: Updating Data
connection con4;
UPDATE t1 SET details='ONLINETEST1' WHERE id=2;

#############
#Delete Data#
#############

--echo
--echo con5: Deleting Data
connection con5;
DELETE FROM t3 WHERE id=30;

--echo
--echo con3: Signalling that BACKUP can finish
connection con3;
SET DEBUG_SYNC= 'now SIGNAL bup_finish';

--echo
--echo con1: Fetching result of BACKUP
connection con1;
--replace_column 1 #
reap;

--echo
--echo con2: Inserting Data
connection  con2;
INSERT INTO t1 VALUES(1040,'online1040');

--echo
--echo con4: Updating Data
connection con4;
UPDATE t2 SET info='t2 updated4' WHERE id=201;

--echo
--echo con6: **Checking the Data Contents before Restore**
connection con6;
SELECT * FROM t1;
SELECT COUNT(*) FROM t1;
SELECT * FROM t2;
SELECT  COUNT(*) FROM t2;
SELECT *FROM t3;
SELECT  COUNT(*) FROM t3;

##################
#RESTORE DATABASE#
##################

--echo
--echo con1: Dropping the database
connection con1;
DROP DATABASE bup_online;

--echo con1: Restoring the database
--replace_column 1 #
RESTORE FROM 'bup_online.bak';

#check data contents after Restore.
--echo
--echo *** RESULT AFTER RESTORE ***
--echo

SELECT * FROM t1;
SELECT COUNT(*) FROM t1;
SELECT * FROM t2;
SELECT  COUNT(*) FROM t2;
SELECT *FROM t3;
SELECT  COUNT(*) FROM t3;

# Test cleanup section

--echo
--echo ***  DROP bup_online DATABASE ****
--echo

DROP DATABASE bup_online;

remove_file $MYSQLTEST_VARDIR/master-data/bup_online.bak;

