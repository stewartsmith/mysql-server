#
# This test is for the commit blocker
# The goals of the test should be to ensure the following assumptions for
# the behaviour of the commit blocker hold true.
#
# a) transactions in progress are not committed until after the backup
# b) transactions that are committing are allowed to commit
# c) transactions that have not started are allowed to start but do not commit
# d) non-transaction statements in progress are allowed to finish
# e) non-transaction statements that have not started are blocked
#
# The results of the backup should show (based on statements above):
#
# a) Test result for this assumption: Not included in backup
# b) Test result for this assumption: Included in backup
# c) Test result for this assumption: Not included in backup
# d) Test result for this assumption: Included in backup
# e) Test result for this assumption: Not included in backup
#
# Note: the statements above assume statements that change data.
#
# The test shall run three sets of data manipulation statements. 
#
# 1) transactional statments only
# 2) non-transactional statements only
# 3) mix of both transactional and non-transactional statements
#
# TODO : Add a native driver to the test when one becomes available
#

--source include/have_innodb.inc
--source include/have_debug_sync.inc
--source include/not_embedded.inc

--disable_warnings
SET DEBUG_SYNC= 'RESET';
DROP DATABASE IF EXISTS bup_commit_blocker;
--error 0,1
let $MYSQLD_DATADIR= `select @@datadir`;
remove_file $MYSQLD_DATADIR/bup_commit_blocker.bak;
--enable_warnings

CREATE DATABASE bup_commit_blocker;

#
# Connections used in this test
#
# con1 - used to create data, load data, and run the backup 
# con2 - used for setting up transactions in progress
# con3 - used for setting up transactions in commit
# con4 - used for setting up transactions about to start
# con5 - used to show status
# con6 - used for setting up non-transactions in progress
# con7 - used for setting up non-transactions about to start
#

connect (con1,localhost,root,,);
connect (con2,localhost,root,,);
connect (con3,localhost,root,,);
connect (con4,localhost,root,,);
connect (con5,localhost,root,,);
connect (con6,localhost,root,,);
connect (con7,localhost,root,,);

#
# Note: Originally we used SELECT ... FROM INFORMATION_SCHEMA.PROCESSLIST; to show status of 
# the various connections participating in the test. But INFORMATION_SCHEMA.PROCESSLIST implementation
# proved to be not relaiable. From time to time (nondeterminisrtically) test hanged on these SELECTs.
# As showing the status is not essential for the test (we test correctness by checking the contents of
# the created backup image), the selects are commented out now. They can be re-enabled when
# I_S.PROCESSLIST is in a better shape.
#

connection con1;

#
# Test 1 - transactional statements only
#

--echo 
--echo Starting Test 1
--echo 

#
# Test 1 sequence diagram (not UML)
#
#   con1     con2     con3     con4     con5
#  (setup)    |        |        |        |
#     |       |        |        |        |
#     |     BEGIN      |        |        |
#     |    UPDATE t1   |        |        |
#     |       |      BEGIN      |        |
#     |       |     INSERT t2   |        |
#     |       |     INSERT t2   |        |
#     |       |        |        |    show status
#   BACKUP    |        |        |        |
#     |       |      COMMIT     |        |
#     |       |        |        |    show status
#     |       |        |      BEGIN      |
#     |       |        |        |    show status
#     |    DELETE t1   |        |        |
#     |     COMMIT     |        |        |
#     |       |      <...>      |        |
#     |       |        |     UPDATE t3   |
#     |       |        |     COMMIT      |
#   <...>     |        |        |        |
# (results)   |        |        |        |
#
# Note: The resume of the commands is indicated with <...> and
#       may occur in any order.
#

# Create transaction tables and load them with data.
--echo con1: Creating tables
CREATE TABLE bup_commit_blocker.t1 (col_a CHAR(40)) ENGINE=INNODB;
CREATE TABLE bup_commit_blocker.t2 (col_a CHAR(40)) ENGINE=INNODB;
CREATE TABLE bup_commit_blocker.t3 (col_a CHAR(40)) ENGINE=INNODB;

--echo con1: Loading data
INSERT INTO bup_commit_blocker.t1 VALUES ("01 Some data to test");
INSERT INTO bup_commit_blocker.t1 VALUES ("02 Some data to test");
INSERT INTO bup_commit_blocker.t1 VALUES ("03 Some data to test");
INSERT INTO bup_commit_blocker.t1 VALUES ("04 Some data to test");
INSERT INTO bup_commit_blocker.t1 VALUES ("05 Some data to test");

INSERT INTO bup_commit_blocker.t2 VALUES ("01 Some data to test");
INSERT INTO bup_commit_blocker.t2 VALUES ("02 Some data to test");
INSERT INTO bup_commit_blocker.t2 VALUES ("03 Some data to test");
INSERT INTO bup_commit_blocker.t2 VALUES ("04 Some data to test");
INSERT INTO bup_commit_blocker.t2 VALUES ("05 Some data to test");

INSERT INTO bup_commit_blocker.t3 VALUES ("01 Some data to test");
INSERT INTO bup_commit_blocker.t3 VALUES ("02 Some data to test");
INSERT INTO bup_commit_blocker.t3 VALUES ("03 Some data to test");
INSERT INTO bup_commit_blocker.t3 VALUES ("04 Some data to test");
INSERT INTO bup_commit_blocker.t3 VALUES ("05 Some data to test");

--echo con1: Show that the new data doesn't exist before backup.
SELECT * FROM bup_commit_blocker.t1;
SELECT * FROM bup_commit_blocker.t2;
SELECT * FROM bup_commit_blocker.t3;

connection con2;

--echo con2: Get a transaction going and stop in the middle
--echo Assumption (a): TRX in progress is not included in backup
BEGIN;
  UPDATE bup_commit_blocker.t1 SET col_a = "con2: CHANGED" WHERE col_a LIKE '01%';

connection con3;

--echo con3: Start a transaction and send commit after lock is taken
--echo Assumption (b): TRX in commit is included in backup
BEGIN;
  INSERT INTO bup_commit_blocker.t2 VALUES ("con3: 04 Some data to test");
  INSERT INTO bup_commit_blocker.t2 VALUES ("con3: 05 Some data to test");

connection con1;

#
# We must start the backup and allow it to gather the metadata first.
# We stop (with a sync point) the backup after the metadata but before
# the commit blocker.
#
--echo con1: Activate synchronization points for BACKUP.
# Before blocking commits, pause to show processlist state.
# Before going to wait for the protection against global read lock to
# disappear, signal about the wait, so that another thread can continue.
# When COMMIT finishes, it releases the protection against global read lock,
# which would allow BACKUP to continue while COMMIT also continues and
# signals "commit_done". It is important that BACKUP does not run in
# parallel and send another signal without waiting for the commit_done
# signal to be processed. So BACKUP itself has to wait for that signal
# after awaking and taking the global read lock. Only then BACKUP
# can proceed and send a signal telling that it took the global read
# lock. Unfortunately DEBUG_SYNC does not allow a sync point to emit a
# signal after a wait_for action. So we need to send the signal in a later
# sync point. For this test it is not important where this signal is sent,
# as long as it is sent while BACKUP holds the global read lock.
# Here we do it "before_backup_unblock_commit", where we have to
# synchronize anyway.
SET DEBUG_SYNC= 'before_commit_block SIGNAL bup_commit_block
                 WAIT_FOR bup_go_read_lock';
SET DEBUG_SYNC= 'wait_lock_global_read_lock SIGNAL bup_read_lock';
SET DEBUG_SYNC= 'before_backup_data_lock WAIT_FOR commit_done';
SET DEBUG_SYNC= 'before_backup_unblock_commit SIGNAL bup_read_locked
                 WAIT_FOR finish';
--echo con1: Backing up database -- will block with lock
send BACKUP DATABASE bup_commit_blocker TO "bup_commit_blocker.bak";

connection con5;

--echo con5: Wait for BACKUP to reach its synchronization point.
SET DEBUG_SYNC= 'now WAIT_FOR bup_commit_block';
#SELECT state, info FROM
#INFORMATION_SCHEMA.PROCESSLIST
#WHERE info LIKE "BACKUP DATABASE%";

connection con3;

--echo con3: Activate synchronization points for COMMIT.
SET DEBUG_SYNC= 'within_ha_commit_trans SIGNAL commit_read_locked
                 WAIT_FOR commit_go_done';
SET DEBUG_SYNC= 'after_commit SIGNAL commit_done WAIT_FOR finish';
--echo con3: Starting commit -- will block on sync point
send COMMIT;

connection con5;

--echo con5: Wait for COMMIT to reach its synchronization point.
SET DEBUG_SYNC= 'now WAIT_FOR commit_read_locked';
#SELECT state, info FROM
#INFORMATION_SCHEMA.PROCESSLIST
#WHERE info LIKE "COMMIT%";

--echo con5: Let BACKUP run until the next sync point.
SET DEBUG_SYNC= 'now SIGNAL bup_go_read_lock WAIT_FOR bup_read_lock';
#SELECT state, info FROM
#INFORMATION_SCHEMA.PROCESSLIST
#WHERE info LIKE "BACKUP DATABASE%";

--echo con5: Let COMMIT continue until end of statement.
--echo con5: The completed COMMIT implicitly wakes BACKUP.
--echo con5: So wait for BACKUP to reach the next synchronization point.
SET DEBUG_SYNC= 'now SIGNAL commit_go_done WAIT_FOR bup_read_locked';
#SELECT state, info FROM
#INFORMATION_SCHEMA.PROCESSLIST
#WHERE info LIKE "COMMIT%";
#SELECT state, info FROM
#INFORMATION_SCHEMA.PROCESSLIST
#WHERE info LIKE "BACKUP DATABASE%";

connection con4;

--echo con4: Activate synchronization point for BEGIN.
SET DEBUG_SYNC= 'before_begin_trans SIGNAL begin_starting
                 WAIT_FOR finish';
--echo con4: Starting begin -- will block on sync point
--echo Assumption (c): TRX not started is not included in backup
send BEGIN;

connection con5;

--echo con5: Wait for BEGIN to reach its synchronization point.
SET DEBUG_SYNC= 'now WAIT_FOR begin_starting';
#SELECT state, info FROM
#INFORMATION_SCHEMA.PROCESSLIST
#WHERE info LIKE "BEGIN%";

--echo con5: Sending finish signal to wake them all.
SET DEBUG_SYNC= 'now SIGNAL finish';

# Reconnect to connections and fetch their results.

connection con2;

--echo con2: Completing transaction
  DELETE FROM bup_commit_blocker.t1 WHERE col_a LIKE '02%';
COMMIT;

connection con3;

--echo con3: Fetch COMMIT result
reap;

connection con4;

--echo con4: Fetch BEGIN result and completing transaction
reap;
  UPDATE bup_commit_blocker.t3 SET col_a = "con4: 05 CHANGED" WHERE col_a LIKE '05%';
  UPDATE bup_commit_blocker.t3 SET col_a = "con4: 06 CHANGED" WHERE col_a LIKE '06%';
COMMIT;

connection con1;

--echo con1: Fetch BACKUP result
--replace_column 1 #
reap;

# Now restore the database and then check to make sure the new rows
# were not backed up.

# Do selects to show that all changes got applied.
--echo con1: Showing data after updates and backup
SELECT * FROM bup_commit_blocker.t1;
SELECT * FROM bup_commit_blocker.t2;
SELECT * FROM bup_commit_blocker.t3;

--echo con1: Dropping the database
DROP TABLE bup_commit_blocker.t1;
DROP TABLE bup_commit_blocker.t2;
DROP TABLE bup_commit_blocker.t3;

--echo con1: Restoring the database
--replace_column 1 #
 RESTORE FROM "bup_commit_blocker.bak";

--echo con1: Showing the data (no new data should be here).
SELECT * FROM bup_commit_blocker.t1;
SELECT * FROM bup_commit_blocker.t2;
SELECT * FROM bup_commit_blocker.t3;

--echo
--echo Verifying test 1 results:
--echo

--echo T1 should not have the changes after backup - count(*) = 0
SELECT count(*) FROM bup_commit_blocker.t1 WHERE col_a like 'con2%';

--echo T2 should have the changes after backup - count(*) = 2
SELECT count(*) FROM bup_commit_blocker.t2 WHERE col_a like 'con3%';

--echo T3 should not have the changes after backup - count(*) = 0
SELECT count(*) FROM bup_commit_blocker.t3 WHERE col_a like 'con4%';

--echo con1: Cleanup
DROP DATABASE bup_commit_blocker;

remove_file $MYSQLD_DATADIR/bup_commit_blocker.bak;
SET DEBUG_SYNC= 'RESET';

#
# Test 2 - non-transactional statements only
#

--echo 
--echo Starting Test 2
--echo 

# Ingo: DELETE was disabled before converting the test from
#       BACKUP_BREAKPOINT to DEBUG_SYNC. I left it disabled
#       as an attempt to enable it made an infinite loop in
#       write_table_data() in the loop:
#    while (sch.prepare_count > 0)
#    if (sch.step())
#      goto error;
#        sch.prepare_count did not change from being 1.
#        When this is fixed, please remove this comment.

#
# Test 2 sequence diagram (not UML)
#
#   con1     con2     con3     con4     con5     con6       con7
#  (setup)    |        |        |        |        |          |
#     |       |        |        |        |        |          |
#     |       |        |        |        |   #DELETE t4      |
#     |       |        |        |   #show status  |          |
#   BACKUP    |        |        |        |        |          |
#     |       |        |        |    show status  |          |
#     |       |        |        |        |        |       (results)
#     |       |        |        |        |        |       UPDATE t5
#     |       |        |        |    show status  |          |
#   <...>     |        |        |        |      <...>      <...>
# (results)   |        |        |        |        |          |
#
# Note: The resume of the commands is indicated with <...> and
#       may occur in any order.
#

CREATE DATABASE bup_commit_blocker;

# Create a non-transaction table and load it with data.
--echo con1: Creating tables
#CREATE TABLE bup_commit_blocker.t4 (col_a int) ENGINE=MEMORY;
CREATE TABLE bup_commit_blocker.t5 (col_a int) ENGINE=MEMORY;

--echo con1: Loading data
#INSERT INTO bup_commit_blocker.t4 VALUES (1), (2), (3), (4), (5);
INSERT INTO bup_commit_blocker.t5 VALUES (10), (20), (30), (40), (50);

--echo con1: Show that the new data doesn't exist before backup.
#SELECT * FROM bup_commit_blocker.t4;
SELECT * FROM bup_commit_blocker.t5;

#connection con6;
#
#--echo con6: Activate synchronization point for DELETE.
#SET DEBUG_SYNC= 'at_delete_end SIGNAL del_at_end WAIT_FOR finish';
#--echo con6: Starting non-trx in progress -- will block with lock
#--echo Assumption (d): non-TRX in progress is included in backup
#send DELETE FROM bup_commit_blocker.t4 WHERE col_a <= 2;
#
#connection con5;
#
#--echo con5: Wait for DELETE to reach its synchronization point.
#SET DEBUG_SYNC= 'now WAIT_FOR del_at_end';
#SELECT state, info FROM
#INFORMATION_SCHEMA.PROCESSLIST
#WHERE info LIKE "DELETE%";

connection con1;

--echo con1: Activate synchronization point for BACKUP.
SET DEBUG_SYNC= 'before_backup_data_unlock SIGNAL bup_data_unlock
                 WAIT_FOR finish';
--echo con1: Backing up database -- will block with lock
send BACKUP DATABASE bup_commit_blocker TO "bup_commit_blocker.bak";

connection con5;

--echo con5: Wait for BACKUP to reach its synchronization point.
SET DEBUG_SYNC= 'now WAIT_FOR bup_data_unlock';
#SELECT state, info FROM
#INFORMATION_SCHEMA.PROCESSLIST
#WHERE info LIKE "BACKUP DATABASE%";

connection con7;

--echo con7: Show that the statement in progress has executed before backup.
#SELECT * FROM bup_commit_blocker.t4;
SELECT * FROM bup_commit_blocker.t5;

--echo con7: Activate synchronization point for UPDATE.
SET DEBUG_SYNC= 'wait_if_global_read_lock SIGNAL upd_read_lock';
--echo con7: Starting non-trx about to start
--echo Assumption (e): non-TRX not started is not included in backup
send UPDATE bup_commit_blocker.t5 SET col_a = 333 WHERE col_a = 30;

connection con5;

--echo con5: Wait for UPDATE to reach its synchronization point.
SET DEBUG_SYNC= 'now WAIT_FOR upd_read_lock';
#SELECT state, info FROM
#INFORMATION_SCHEMA.PROCESSLIST
#WHERE info LIKE "UPDATE%";

--echo con5: Sending finish signal to wake them all.
SET DEBUG_SYNC= 'now SIGNAL finish';

# Reconnect to con6 and con7 and fetch their results.

#connection con6;
#
#--echo con6: Fetch DELETE result
#reap;

connection con7;

--echo con7: Fetch UPDATE result
reap;

connection con1;

--echo con1: Fetch BACKUP result
--replace_column 1 #
reap;

# Now restore the database and then check to make sure the new rows
# were not backed up.

# Do selects to show that all changes got applied.
--echo con1: Showing data after updates and backup
#SELECT * FROM bup_commit_blocker.t4;
SELECT * FROM bup_commit_blocker.t5;

--echo con1: Dropping the database
#DROP TABLE bup_commit_blocker.t4;
DROP TABLE bup_commit_blocker.t5;

--echo con1: Restoring the database
--replace_column 1 #
 RESTORE FROM "bup_commit_blocker.bak";

--echo con1: Showing the data (no new data should be here).
#SELECT * FROM bup_commit_blocker.t4;
SELECT * FROM bup_commit_blocker.t5;

--echo
--echo Verifying test 2 results:
--echo

#--echo T4 should have the changes after backup - count(*) = 3
#SELECT count(*) FROM bup_commit_blocker.t4 WHERE col_a > 2;

--echo T5 should not have the changes after backup - count(*) = 0
SELECT count(*) FROM bup_commit_blocker.t5 WHERE col_a = 333;

--echo con1: Cleanup
DROP DATABASE bup_commit_blocker;

remove_file $MYSQLD_DATADIR/bup_commit_blocker.bak;
SET DEBUG_SYNC= 'RESET';

#
# Test 3 - mix of both transactional and non-transactional statements
#

--echo 
--echo Starting Test 3
--echo 

#
# Test 3 sequence diagram (not UML)
#
#   con1     con2     con3     con4     con5     con6       con7
#  (setup)    |        |        |        |        |          |
#     |       |        |        |        |        |          |
#     |     BEGIN      |        |        |        |          |
#     |    UPDATE t1   |        |        |        |          |
#     |       |      BEGIN      |        |        |          |
#     |       |     INSERT t2   |        |        |          |
#     |       |     INSERT t2   |        |        |          |
#   BACKUP    |        |        |        |        |          |
#     |       |        |        |        |    #INSERT t4     |
#     |       |        |        |    show status  |          |
#     |       |      COMMIT     |        |        |          |
#     |       |        |        |    show status  |          |
#     |       |        |      BEGIN      |        |          |
#     |       |        |        |    show status  |          |
#     |       |        |        |        |        |      (results)
#     |       |        |        |        |        |       DELETE t5
#     |       |        |        |    show status  |          |
#     |       |        |        |     wake all    |          |
#     |    DELETE t1   |        |        |        |          |
#     |     COMMIT     |        |        |        |          |
#     |       |      <...>      |        |        |          |
#     |       |        |     UPDATE t3   |        |          |
#     |       |        |     UPDATE t3   |        |          |
#     |       |        |     COMMIT      |        |          |
#   <...>     |        |        |        |      <...>      <...>
# (results)   |        |        |        |        |          |
#
# Note: The resume of the commands is indicated with <...> and
#       may occur in any order.
#

CREATE DATABASE bup_commit_blocker;

# Create tables and load them with data.
--echo con1: Creating tables
CREATE TABLE bup_commit_blocker.t1 (col_a CHAR(40)) ENGINE=INNODB;
CREATE TABLE bup_commit_blocker.t2 (col_a CHAR(40)) ENGINE=INNODB;
CREATE TABLE bup_commit_blocker.t3 (col_a CHAR(40)) ENGINE=INNODB;
#CREATE TABLE bup_commit_blocker.t4 (col_a int) ENGINE=MEMORY;
CREATE TABLE bup_commit_blocker.t5 (col_a int) ENGINE=MEMORY;

--echo con1: Loading data
INSERT INTO bup_commit_blocker.t1 VALUES ("01 Some data to test");
INSERT INTO bup_commit_blocker.t1 VALUES ("02 Some data to test");
INSERT INTO bup_commit_blocker.t1 VALUES ("03 Some data to test");
INSERT INTO bup_commit_blocker.t1 VALUES ("04 Some data to test");
INSERT INTO bup_commit_blocker.t1 VALUES ("05 Some data to test");

INSERT INTO bup_commit_blocker.t2 VALUES ("01 Some data to test");
INSERT INTO bup_commit_blocker.t2 VALUES ("02 Some data to test");
INSERT INTO bup_commit_blocker.t2 VALUES ("03 Some data to test");
INSERT INTO bup_commit_blocker.t2 VALUES ("04 Some data to test");
INSERT INTO bup_commit_blocker.t2 VALUES ("05 Some data to test");

INSERT INTO bup_commit_blocker.t3 VALUES ("01 Some data to test");
INSERT INTO bup_commit_blocker.t3 VALUES ("02 Some data to test");
INSERT INTO bup_commit_blocker.t3 VALUES ("03 Some data to test");
INSERT INTO bup_commit_blocker.t3 VALUES ("04 Some data to test");
INSERT INTO bup_commit_blocker.t3 VALUES ("05 Some data to test");

#INSERT INTO bup_commit_blocker.t4 VALUES (1), (2), (3), (4), (5);
INSERT INTO bup_commit_blocker.t5 VALUES (10), (20), (30), (40), (50);

--echo con1: Show that the new data doesn't exist before backup.
SELECT * FROM bup_commit_blocker.t1;
SELECT * FROM bup_commit_blocker.t2;
SELECT * FROM bup_commit_blocker.t3;
#SELECT * FROM bup_commit_blocker.t4;
SELECT * FROM bup_commit_blocker.t5;

connection con2;

--echo con2: Get a transaction going and stop in the middle
--echo Assumption (a): TRX in progress is not included in backup
BEGIN;
  UPDATE bup_commit_blocker.t1 SET col_a = "con2: CHANGED" WHERE col_a LIKE '01%';

connection con3;

--echo con3: Start a transaction and send commit after lock is taken
--echo Assumption (b): TRX in commit is included in backup
BEGIN;
  INSERT INTO bup_commit_blocker.t2 VALUES ("con3: 04 Some data to test");
  INSERT INTO bup_commit_blocker.t2 VALUES ("con3: 05 Some data to test");

connection con1;

#
# We must start the backup and allow it to gather the metadata first.
# We stop (with a sync point) the backup after the metadata but before
# the commit blocker.
#
--echo con1: Activate synchronization points for BACKUP.
# Before blocking commits, pause to show processlist state.
# Before going to wait for the protection against global read lock to
# disappear, signal about the wait, so that another thread can continue.
# When COMMIT finishes, it releases the protection against global read lock,
# which would allow BACKUP to continue while COMMIT also continues and
# signals "commit_done". It is important that BACKUP does not run in
# parallel and send another signal without waiting for the commit_done
# signal to be processed. So BACKUP itself has to wait for that signal
# after awaking and taking the global read lock. Only then BACKUP
# can proceed and send a signal telling that it took the global read
# lock. Unfortunately DEBUG_SYNC does not allow a sync point to emit a
# signal after a wait_for action. So we need to send the signal in a later
# sync point. For this test it is not important where this signal is sent,
# as long as it is sent while BACKUP holds the global read lock.
# Here we do it "before_backup_unblock_commit", where we have to
# synchronize anyway.
SET DEBUG_SYNC= 'before_commit_block SIGNAL bup_commit_block
                 WAIT_FOR bup_go_read_lock';
SET DEBUG_SYNC= 'wait_lock_global_read_lock SIGNAL bup_read_lock';
SET DEBUG_SYNC= 'before_backup_data_lock WAIT_FOR commit_done';
SET DEBUG_SYNC= 'before_backup_unblock_commit SIGNAL bup_read_locked
                 WAIT_FOR finish';
--echo con1: Backing up database -- will block with lock
send BACKUP DATABASE bup_commit_blocker TO "bup_commit_blocker.bak";

#connection con6;
#
#--echo con6: Activate synchronization point for INSERT.
#SET DEBUG_SYNC= 'after_insert_locked_tables SIGNAL insert_table_locked
#                 WAIT_FOR finish';
#--echo con6: Starting non-trx in progress -- will block
#--echo Assumption (d): non-TRX in progress is included in backup
#send INSERT INTO bup_commit_blocker.t4 VALUES (31), (32), (33);

connection con5;

--echo con5: Wait for BACKUP to reach its synchronization point.
SET DEBUG_SYNC= 'now WAIT_FOR bup_commit_block';
#SELECT state, info FROM
#INFORMATION_SCHEMA.PROCESSLIST
#WHERE info LIKE "BACKUP DATABASE%";

#--echo con5: Wait for INSERT to reach its synchronization point.
#SET DEBUG_SYNC= 'now WAIT_FOR insert_table_locked';
#SELECT state, info FROM
#INFORMATION_SCHEMA.PROCESSLIST
#WHERE info LIKE "BACKUP DATABASE%";

connection con3;

--echo con3: Activate synchronization points for COMMIT.
SET DEBUG_SYNC= 'within_ha_commit_trans SIGNAL commit_read_locked
                 WAIT_FOR commit_go_done';
SET DEBUG_SYNC= 'after_commit SIGNAL commit_done WAIT_FOR finish';
--echo con3: Starting commit -- will block on sync point
send COMMIT;

connection con5;

--echo con5: Wait for COMMIT to reach its synchronization point.
SET DEBUG_SYNC= 'now WAIT_FOR commit_read_locked';
#SELECT state, info FROM
#INFORMATION_SCHEMA.PROCESSLIST
#WHERE info LIKE "COMMIT%";

--echo con5: Let BACKUP run until the next sync point.
SET DEBUG_SYNC= 'now SIGNAL bup_go_read_lock WAIT_FOR bup_read_lock';
#SELECT state, info FROM
#INFORMATION_SCHEMA.PROCESSLIST
#WHERE info LIKE "BACKUP DATABASE%";

--echo con5: Let COMMIT continue until the sync point at its end.
--echo con5: The completed COMMIT implicitly wakes BACKUP.
--echo con5: So wait for BACKUP to reach the next synchronization point.
SET DEBUG_SYNC= 'now SIGNAL commit_go_done WAIT_FOR bup_read_locked';
#SELECT state, info FROM
#INFORMATION_SCHEMA.PROCESSLIST
#WHERE info LIKE "COMMIT%";
#SELECT state, info FROM
#INFORMATION_SCHEMA.PROCESSLIST
#WHERE info LIKE "BACKUP DATABASE%";

connection con4;

--echo con4: Activate synchronization point for BEGIN.
SET DEBUG_SYNC= 'before_begin_trans SIGNAL begin_starting
                 WAIT_FOR finish';
--echo con4: Starting begin -- will block with lock
--echo Assumption (c): TRX not started is not included in backup
send BEGIN;

connection con5;

--echo con5: Wait for BEGIN to reach its synchronization point.
SET DEBUG_SYNC= 'now WAIT_FOR begin_starting';
#SELECT state, info FROM
#INFORMATION_SCHEMA.PROCESSLIST
#WHERE info LIKE "BEGIN%";

connection con7;

--echo con7: Show that the statement in progress has executed before backup.
#SELECT * FROM bup_commit_blocker.t4;
SELECT * FROM bup_commit_blocker.t5;

--echo con7: Activate synchronization point for DELETE.
SET DEBUG_SYNC= 'wait_if_global_read_lock SIGNAL del_read_lock';
--echo con7: Starting non-trx about to start -- will block with lock
--echo Assumption (e): non-TRX not started is not included in backup
send DELETE FROM bup_commit_blocker.t5 WHERE col_a = 50;

connection con5;

--echo con5: Wait for DELETE to reach its synchronization point.
SET DEBUG_SYNC= 'now WAIT_FOR del_read_lock';
#SELECT state, info FROM
#INFORMATION_SCHEMA.PROCESSLIST
#WHERE info LIKE "DELETE%";

--echo con5: Sending finish signal to wake them all.
SET DEBUG_SYNC= 'now SIGNAL finish';

# Reconnect to con2, con3, con4, con6, and con7 and fetch their results.

connection con2;

--echo con2: Completing transaction
  DELETE FROM bup_commit_blocker.t2 WHERE col_a LIKE '02%';
COMMIT;

connection con3;

--echo con3: Fetch COMMIT result
reap;

connection con4;

--echo con4: Fetch BEGIN result and completing transaction
reap;
  UPDATE bup_commit_blocker.t3 SET col_a = "con4: 05 CHANGED" WHERE col_a LIKE '05%';
  UPDATE bup_commit_blocker.t3 SET col_a = "con4: 06 CHANGED" WHERE col_a LIKE '06%';
COMMIT;

connection con6;

#--echo con6: Fetch INSERT result
#reap;

connection con7;

--echo con7: Fetch DELETE result
reap;

connection con1;

--echo con1: Fetch BACKUP result
--replace_column 1 #
reap;

# Now restore the database and then check to make sure the new rows
# were not backed up.

# Do selects to show that all changes got applied.
--echo con1: Showing data after updates and backup
SELECT * FROM bup_commit_blocker.t1;
SELECT * FROM bup_commit_blocker.t2;
SELECT * FROM bup_commit_blocker.t3;
#SELECT * FROM bup_commit_blocker.t4;
SELECT * FROM bup_commit_blocker.t5;

--echo con1: Dropping the database
DROP TABLE bup_commit_blocker.t1;
DROP TABLE bup_commit_blocker.t2;
DROP TABLE bup_commit_blocker.t3;
#DROP TABLE bup_commit_blocker.t4;
DROP TABLE bup_commit_blocker.t5;

--echo con1: Restoring the database
--replace_column 1 #
RESTORE FROM "bup_commit_blocker.bak";

--echo con1: Showing the data (no new data should be here).
SELECT * FROM bup_commit_blocker.t1;
SELECT * FROM bup_commit_blocker.t2;
SELECT * FROM bup_commit_blocker.t3;
#SELECT * FROM bup_commit_blocker.t4;
SELECT * FROM bup_commit_blocker.t5;

--echo
--echo Verifying test 3 results:
--echo

--echo T1 should not have the changes after backup - count(*) = 0
SELECT count(*) FROM bup_commit_blocker.t1 WHERE col_a like 'con2%';

--echo T2 should have the changes after backup - count(*) = 2
SELECT count(*) FROM bup_commit_blocker.t2 WHERE col_a like 'con3%';

--echo T3 should not have the changes after backup - count(*) = 0
SELECT count(*) FROM bup_commit_blocker.t3 WHERE col_a like 'con4%';

#--echo T4 should have the changes after backup - count(*) = 3
#SELECT count(*) FROM bup_commit_blocker.t4 WHERE col_a > 30;

--echo T5 should not have the changes after backup - count(*) = 1
SELECT count(*) FROM bup_commit_blocker.t5 WHERE col_a >= 50;

--echo con1: Cleanup
DROP DATABASE bup_commit_blocker;

remove_file $MYSQLD_DATADIR/bup_commit_blocker.bak;
SET DEBUG_SYNC= 'RESET';

